#![doc = "Peripheral access API for RK3399 microcontrollers (generated using svd2rust v0.32.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.32.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 4;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc(hidden)]
pub mod interrupt;
pub use self::interrupt::Interrupt;
#[doc = "Cache Coherent Interconnect 500 (CCI500) Registers"]
pub struct Cci500 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cci500 {}
impl Cci500 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cci500::RegisterBlock = 0xffb0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cci500::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cci500 {
    type Target = cci500::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cci500 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cci500").finish()
    }
}
#[doc = "Cache Coherent Interconnect 500 (CCI500) Registers"]
pub mod cci500;
#[doc = "Clock and Reset Unit (CRU) Registers"]
pub struct Cru {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cru {}
impl Cru {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cru::RegisterBlock = 0xff76_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cru::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cru {
    type Target = cru::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cru {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cru").finish()
    }
}
#[doc = "Clock and Reset Unit (CRU) Registers"]
pub mod cru;
#[doc = "Crypto Registers"]
pub struct Crypto {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crypto {}
impl Crypto {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crypto::RegisterBlock = 0xff8b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crypto::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crypto {
    type Target = crypto::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crypto {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crypto").finish()
    }
}
#[doc = "Crypto Registers"]
pub mod crypto;
#[doc = "Crypto 0 Registers"]
pub struct Crypto0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crypto0 {}
impl Crypto0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crypto::RegisterBlock = 0xff8b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crypto::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crypto0 {
    type Target = crypto::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crypto0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crypto0").finish()
    }
}
#[doc = "Crypto 0 Registers"]
pub use self::crypto as crypto0;
#[doc = "Crypto 1 Registers"]
pub struct Crypto1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crypto1 {}
impl Crypto1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crypto::RegisterBlock = 0xff8b_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crypto::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crypto1 {
    type Target = crypto::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crypto1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crypto1").finish()
    }
}
#[doc = "Crypto 1 Registers"]
pub use self::crypto as crypto1;
#[doc = "DDR Converser of Frequency (DCF) Registers"]
pub struct Dcf {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dcf {}
impl Dcf {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcf::RegisterBlock = 0xff6a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcf::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dcf {
    type Target = dcf::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dcf {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dcf").finish()
    }
}
#[doc = "DDR Converser of Frequency (DCF) Registers"]
pub mod dcf;
#[doc = "DDR Controller (DDRC) Registers"]
pub struct Ddrc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ddrc {}
impl Ddrc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ddrc::RegisterBlock = 0xffa8_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ddrc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ddrc {
    type Target = ddrc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ddrc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ddrc").finish()
    }
}
#[doc = "DDR Controller (DDRC) Registers"]
pub mod ddrc;
#[doc = "DDR Controller 0 (DDRC0) Registers"]
pub struct Ddrc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ddrc0 {}
impl Ddrc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ddrc::RegisterBlock = 0xffa8_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ddrc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ddrc0 {
    type Target = ddrc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ddrc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ddrc0").finish()
    }
}
#[doc = "DDR Controller 0 (DDRC0) Registers"]
pub use self::ddrc as ddrc0;
#[doc = "DDR Controller 1 (DDRC1) Registers"]
pub struct Ddrc1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ddrc1 {}
impl Ddrc1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ddrc::RegisterBlock = 0xffa8_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ddrc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ddrc1 {
    type Target = ddrc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ddrc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ddrc1").finish()
    }
}
#[doc = "DDR Controller 1 (DDRC1) Registers"]
pub use self::ddrc as ddrc1;
#[doc = "DDR Controller Interface Control Registers (DDR_CIC) Registers"]
pub struct DdrCic {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DdrCic {}
impl DdrCic {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ddr_cic::RegisterBlock = 0xff62_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ddr_cic::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DdrCic {
    type Target = ddr_cic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DdrCic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DdrCic").finish()
    }
}
#[doc = "DDR Controller Interface Control Registers (DDR_CIC) Registers"]
pub mod ddr_cic;
#[doc = "DDR Monitor (DDR_MON) Registers"]
pub struct DdrMon {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DdrMon {}
impl DdrMon {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ddr_mon::RegisterBlock = 0xff63_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ddr_mon::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DdrMon {
    type Target = ddr_mon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DdrMon {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DdrMon").finish()
    }
}
#[doc = "DDR Monitor (DDR_MON) Registers"]
pub mod ddr_mon;
#[doc = "DMA Controller (DMAC) Registers"]
pub struct Dmac {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmac {}
impl Dmac {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmac::RegisterBlock = 0xff6d_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmac {
    type Target = dmac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac").finish()
    }
}
#[doc = "DMA Controller (DMAC) Registers"]
pub mod dmac;
#[doc = "DMA Controller 0 Registers"]
pub struct Dmac0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmac0 {}
impl Dmac0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmac::RegisterBlock = 0xff6d_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmac0 {
    type Target = dmac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmac0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac0").finish()
    }
}
#[doc = "DMA Controller 0 Registers"]
pub use self::dmac as dmac0;
#[doc = "DMA Controller 1 Registers"]
pub struct Dmac1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmac1 {}
impl Dmac1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmac::RegisterBlock = 0xff6e_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmac1 {
    type Target = dmac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmac1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac1").finish()
    }
}
#[doc = "DMA Controller 1 Registers"]
pub use self::dmac as dmac1;
#[doc = "DisplayPort Registers"]
pub struct Dp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dp {}
impl Dp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dp::RegisterBlock = 0xfec0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dp {
    type Target = dp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dp").finish()
    }
}
#[doc = "DisplayPort Registers"]
pub mod dp;
#[doc = "eFuse Registers"]
pub struct Efuse {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Efuse {}
impl Efuse {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const efuse::RegisterBlock = 0xff69_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const efuse::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Efuse {
    type Target = efuse::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Efuse {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Efuse").finish()
    }
}
#[doc = "eFuse Registers"]
pub mod efuse;
#[doc = "eFuse 0 Registers"]
pub struct Efuse0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Efuse0 {}
impl Efuse0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const efuse::RegisterBlock = 0xff69_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const efuse::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Efuse0 {
    type Target = efuse::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Efuse0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Efuse0").finish()
    }
}
#[doc = "eFuse 0 Registers"]
pub use self::efuse as efuse0;
#[doc = "eFuse 1 Registers"]
pub struct Efuse1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Efuse1 {}
impl Efuse1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const efuse::RegisterBlock = 0xfffa_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const efuse::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Efuse1 {
    type Target = efuse::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Efuse1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Efuse1").finish()
    }
}
#[doc = "eFuse 1 Registers"]
pub use self::efuse as efuse1;
#[doc = "eMMC Controller (EMMCCORE) Registers"]
pub struct Emmccore {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Emmccore {}
impl Emmccore {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const emmccore::RegisterBlock = 0xfe33_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const emmccore::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Emmccore {
    type Target = emmccore::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Emmccore {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Emmccore").finish()
    }
}
#[doc = "eMMC Controller (EMMCCORE) Registers"]
pub mod emmccore;
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters to the memory schedule"]
pub struct ErrLoggerMsch {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ErrLoggerMsch {}
impl ErrLoggerMsch {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const err_logger_msch::RegisterBlock = 0xffa8_7c80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const err_logger_msch::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ErrLoggerMsch {
    type Target = err_logger_msch::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ErrLoggerMsch {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ErrLoggerMsch").finish()
    }
}
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters to the memory schedule"]
pub mod err_logger_msch;
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters to the memory schedule 0"]
pub struct ErrLoggerMsch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ErrLoggerMsch0 {}
impl ErrLoggerMsch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const err_logger_msch::RegisterBlock = 0xffa8_7c80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const err_logger_msch::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ErrLoggerMsch0 {
    type Target = err_logger_msch::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ErrLoggerMsch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ErrLoggerMsch0").finish()
    }
}
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters to the memory schedule 0"]
pub use self::err_logger_msch as err_logger_msch0;
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters to the memory schedule 1"]
pub struct ErrLoggerMsch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ErrLoggerMsch1 {}
impl ErrLoggerMsch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const err_logger_msch::RegisterBlock = 0xffa8_fc80 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const err_logger_msch::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ErrLoggerMsch1 {
    type Target = err_logger_msch::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ErrLoggerMsch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ErrLoggerMsch1").finish()
    }
}
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters to the memory schedule 1"]
pub use self::err_logger_msch as err_logger_msch1;
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters except the PMU of the Cortex-M0 to all slaves outside the PMU power domain"]
pub struct ErrLoggerSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ErrLoggerSlv {}
impl ErrLoggerSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const err_logger_slv::RegisterBlock = 0xffa6_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const err_logger_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ErrLoggerSlv {
    type Target = err_logger_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ErrLoggerSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ErrLoggerSlv").finish()
    }
}
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters except the PMU of the Cortex-M0 to all slaves outside the PMU power domain"]
pub mod err_logger_slv;
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters except the PMU of the Cortex-M0 to all slaves outside the PMU power domain"]
pub struct ErrLoggerSlv0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ErrLoggerSlv0 {}
impl ErrLoggerSlv0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const err_logger_slv::RegisterBlock = 0xffa6_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const err_logger_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ErrLoggerSlv0 {
    type Target = err_logger_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ErrLoggerSlv0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ErrLoggerSlv0").finish()
    }
}
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from all masters except the PMU of the Cortex-M0 to all slaves outside the PMU power domain"]
pub use self::err_logger_slv as err_logger_slv0;
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from the PMU of the Cortex-M0 to all slaves inside the PMU power domain"]
pub struct ErrLoggerSlv1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ErrLoggerSlv1 {}
impl ErrLoggerSlv1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const err_logger_slv::RegisterBlock = 0xffa6_8080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const err_logger_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ErrLoggerSlv1 {
    type Target = err_logger_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ErrLoggerSlv1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ErrLoggerSlv1").finish()
    }
}
#[doc = "Error Logger (ERR_LOGGER) Registers for the paths from the PMU of the Cortex-M0 to all slaves inside the PMU power domain"]
pub use self::err_logger_slv as err_logger_slv1;
#[doc = "Gigabit Media Access Controller (GMAC) Registers"]
pub struct Gmac {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gmac {}
impl Gmac {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gmac::RegisterBlock = 0xfe30_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gmac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gmac {
    type Target = gmac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gmac").finish()
    }
}
#[doc = "Gigabit Media Access Controller (GMAC) Registers"]
pub mod gmac;
#[doc = "General Purpose Input/Output (GPIO) Registers"]
pub struct Gpio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio {}
impl Gpio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xff72_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio").finish()
    }
}
#[doc = "General Purpose Input/Output (GPIO) Registers"]
pub mod gpio;
#[doc = "General Purpose Input/Output (GPIO) 0 Registers"]
pub struct Gpio0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio0 {}
impl Gpio0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xff72_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio0 {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio0").finish()
    }
}
#[doc = "General Purpose Input/Output (GPIO) 0 Registers"]
pub use self::gpio as gpio0;
#[doc = "General Purpose Input/Output (GPIO) 1 Registers"]
pub struct Gpio1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio1 {}
impl Gpio1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xff73_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio1 {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio1").finish()
    }
}
#[doc = "General Purpose Input/Output (GPIO) 1 Registers"]
pub use self::gpio as gpio1;
#[doc = "General Purpose Input/Output (GPIO) 2 Registers"]
pub struct Gpio2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio2 {}
impl Gpio2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xff78_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio2 {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio2").finish()
    }
}
#[doc = "General Purpose Input/Output (GPIO) 2 Registers"]
pub use self::gpio as gpio2;
#[doc = "General Purpose Input/Output (GPIO) 3 Registers"]
pub struct Gpio3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio3 {}
impl Gpio3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xff78_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio3 {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio3").finish()
    }
}
#[doc = "General Purpose Input/Output (GPIO) 3 Registers"]
pub use self::gpio as gpio3;
#[doc = "General Purpose Input/Output (GPIO) 4 Registers"]
pub struct Gpio4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio4 {}
impl Gpio4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xff79_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio4 {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio4").finish()
    }
}
#[doc = "General Purpose Input/Output (GPIO) 4 Registers"]
pub use self::gpio as gpio4;
#[doc = "General Register File (GRF) Registers"]
pub struct Grf {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Grf {}
impl Grf {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const grf::RegisterBlock = 0xff77_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const grf::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Grf {
    type Target = grf::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Grf {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Grf").finish()
    }
}
#[doc = "General Register File (GRF) Registers"]
pub mod grf;
#[doc = "HDMI Registers"]
pub struct Hdmi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hdmi {}
impl Hdmi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hdmi::RegisterBlock = 0xff94_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hdmi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hdmi {
    type Target = hdmi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hdmi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hdmi").finish()
    }
}
#[doc = "HDMI Registers"]
pub mod hdmi;
#[doc = "Inter-IC Sound (I2S) Registers"]
pub struct I2s {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s {}
impl I2s {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s::RegisterBlock = 0xff88_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s {
    type Target = i2s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s").finish()
    }
}
#[doc = "Inter-IC Sound (I2S) Registers"]
pub mod i2s;
#[doc = "Inter-IC Sound (I2S) 0 Registers"]
pub struct I2s0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s0 {}
impl I2s0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s::RegisterBlock = 0xff88_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s0 {
    type Target = i2s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s0").finish()
    }
}
#[doc = "Inter-IC Sound (I2S) 0 Registers"]
pub use self::i2s as i2s0;
#[doc = "Inter-IC Sound (I2S) 1 Registers"]
pub struct I2s1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s1 {}
impl I2s1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s::RegisterBlock = 0xff89_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s1 {
    type Target = i2s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s1").finish()
    }
}
#[doc = "Inter-IC Sound (I2S) 1 Registers"]
pub use self::i2s as i2s1;
#[doc = "Inter-IC Sound (I2S) 2 Registers"]
pub struct I2s2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s2 {}
impl I2s2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s::RegisterBlock = 0xff8a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s2 {
    type Target = i2s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s2").finish()
    }
}
#[doc = "Inter-IC Sound (I2S) 2 Registers"]
pub use self::i2s as i2s2;
#[doc = "Image Enhancement Processor (IEP) Registers"]
pub struct Iep {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iep {}
impl Iep {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iep::RegisterBlock = 0xff67_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iep::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iep {
    type Target = iep::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iep").finish()
    }
}
#[doc = "Image Enhancement Processor (IEP) Registers"]
pub mod iep;
#[doc = "Image Signal Processor (ISP) Registers"]
pub struct Isp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Isp {}
impl Isp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const isp::RegisterBlock = 0xff91_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const isp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Isp {
    type Target = isp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Isp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Isp").finish()
    }
}
#[doc = "Image Signal Processor (ISP) Registers"]
pub mod isp;
#[doc = "Image Signal Processor 0 (ISP0) Registers"]
pub struct Isp0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Isp0 {}
impl Isp0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const isp::RegisterBlock = 0xff91_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const isp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Isp0 {
    type Target = isp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Isp0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Isp0").finish()
    }
}
#[doc = "Image Signal Processor 0 (ISP0) Registers"]
pub use self::isp as isp0;
#[doc = "Image Signal Processor 1 (ISP1) Registers"]
pub struct Isp1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Isp1 {}
impl Isp1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const isp::RegisterBlock = 0xff92_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const isp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Isp1 {
    type Target = isp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Isp1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Isp1").finish()
    }
}
#[doc = "Image Signal Processor 1 (ISP1) Registers"]
pub use self::isp as isp1;
#[doc = "Mailbox Registers"]
pub struct Mailbox {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox {}
impl Mailbox {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox::RegisterBlock = 0xff6b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox {
    type Target = mailbox::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox").finish()
    }
}
#[doc = "Mailbox Registers"]
pub mod mailbox;
#[doc = "Mailbox 0 Registers"]
pub struct Mailbox0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0 {}
impl Mailbox0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox::RegisterBlock = 0xff6b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0 {
    type Target = mailbox::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0").finish()
    }
}
#[doc = "Mailbox 0 Registers"]
pub use self::mailbox as mailbox0;
#[doc = "Mailbox 1 Registers"]
pub struct Mailbox1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox1 {}
impl Mailbox1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox::RegisterBlock = 0xff39_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox1 {
    type Target = mailbox::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox1").finish()
    }
}
#[doc = "Mailbox 1 Registers"]
pub use self::mailbox as mailbox1;
#[doc = "MIPI Display Serial Interface (DSI) Host Registers"]
pub struct MipiDsiHost {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MipiDsiHost {}
impl MipiDsiHost {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mipi_dsi_host::RegisterBlock = 0xff96_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mipi_dsi_host::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MipiDsiHost {
    type Target = mipi_dsi_host::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MipiDsiHost {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MipiDsiHost").finish()
    }
}
#[doc = "MIPI Display Serial Interface (DSI) Host Registers"]
pub mod mipi_dsi_host;
#[doc = "MIPI Display Serial Interface (DSI) Host 0 Registers"]
pub struct MipiDsiHost0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MipiDsiHost0 {}
impl MipiDsiHost0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mipi_dsi_host::RegisterBlock = 0xff96_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mipi_dsi_host::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MipiDsiHost0 {
    type Target = mipi_dsi_host::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MipiDsiHost0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MipiDsiHost0").finish()
    }
}
#[doc = "MIPI Display Serial Interface (DSI) Host 0 Registers"]
pub use self::mipi_dsi_host as mipi_dsi_host0;
#[doc = "MIPI Display Serial Interface (DSI) Host 1 Registers"]
pub struct MipiDsiHost1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MipiDsiHost1 {}
impl MipiDsiHost1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mipi_dsi_host::RegisterBlock = 0xff96_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mipi_dsi_host::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MipiDsiHost1 {
    type Target = mipi_dsi_host::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MipiDsiHost1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MipiDsiHost1").finish()
    }
}
#[doc = "MIPI Display Serial Interface (DSI) Host 1 Registers"]
pub use self::mipi_dsi_host as mipi_dsi_host1;
#[doc = "Memory Management Unit (MMU) Registers"]
pub struct Mmu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmu {}
impl Mmu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff91_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmu {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmu").finish()
    }
}
#[doc = "Memory Management Unit (MMU) Registers"]
pub mod mmu;
#[doc = "Registers of Memory Management Unit 0 (MMU0) for Image Signal Processor 0 (ISP0)"]
pub struct Mmu0Isp0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmu0Isp0 {}
impl Mmu0Isp0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff91_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmu0Isp0 {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmu0Isp0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmu0Isp0").finish()
    }
}
#[doc = "Registers of Memory Management Unit 0 (MMU0) for Image Signal Processor 0 (ISP0)"]
pub use self::mmu as mmu0_isp0;
#[doc = "Registers of Memory Management Unit 0 (MMU0) for Image Signal Processor 1 (ISP1)"]
pub struct Mmu0Isp1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmu0Isp1 {}
impl Mmu0Isp1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff92_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmu0Isp1 {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmu0Isp1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmu0Isp1").finish()
    }
}
#[doc = "Registers of Memory Management Unit 0 (MMU0) for Image Signal Processor 1 (ISP1)"]
pub use self::mmu as mmu0_isp1;
#[doc = "Registers of Memory Management Unit 1 (MMU1) for Image Signal Processor 0 (ISP0)"]
pub struct Mmu1Isp0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmu1Isp0 {}
impl Mmu1Isp0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff91_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmu1Isp0 {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmu1Isp0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmu1Isp0").finish()
    }
}
#[doc = "Registers of Memory Management Unit 1 (MMU1) for Image Signal Processor 0 (ISP0)"]
pub use self::mmu as mmu1_isp0;
#[doc = "Registers of Memory Management Unit 1 (MMU1) for Image Signal Processor 1 (ISP1)"]
pub struct Mmu1Isp1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmu1Isp1 {}
impl Mmu1Isp1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff92_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmu1Isp1 {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmu1Isp1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmu1Isp1").finish()
    }
}
#[doc = "Registers of Memory Management Unit 1 (MMU1) for Image Signal Processor 1 (ISP1)"]
pub use self::mmu as mmu1_isp1;
#[doc = "Registers of Memory Management Unit (MMU) for High-bandwidth Digital Content Protection (HDCP)"]
pub struct MmuHdcp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MmuHdcp {}
impl MmuHdcp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff93_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MmuHdcp {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MmuHdcp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MmuHdcp").finish()
    }
}
#[doc = "Registers of Memory Management Unit (MMU) for High-bandwidth Digital Content Protection (HDCP)"]
pub use self::mmu as mmu_hdcp;
#[doc = "Registers of Memory Management Unit (MMU) for Image Enhancement Processor (IEP)"]
pub struct MmuIep {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MmuIep {}
impl MmuIep {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff67_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MmuIep {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MmuIep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MmuIep").finish()
    }
}
#[doc = "Registers of Memory Management Unit (MMU) for Image Enhancement Processor (IEP)"]
pub use self::mmu as mmu_iep;
#[doc = "Registers of Memory Management Unit (MMU) for Rockchip Video Decoder (RKVDEC) Read"]
pub struct MmuRkvdecR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MmuRkvdecR {}
impl MmuRkvdecR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff66_0480 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MmuRkvdecR {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MmuRkvdecR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MmuRkvdecR").finish()
    }
}
#[doc = "Registers of Memory Management Unit (MMU) for Rockchip Video Decoder (RKVDEC) Read"]
pub use self::mmu as mmu_rkvdec_r;
#[doc = "Registers of Memory Management Unit (MMU) for Rockchip Video Decoder (RKVDEC) Write"]
pub struct MmuRkvdecW {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MmuRkvdecW {}
impl MmuRkvdecW {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff66_04c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MmuRkvdecW {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MmuRkvdecW {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MmuRkvdecW").finish()
    }
}
#[doc = "Registers of Memory Management Unit (MMU) for Rockchip Video Decoder (RKVDEC) Write"]
pub use self::mmu as mmu_rkvdec_w;
#[doc = "Registers of Memory Management Unit (MMU) for Visual Output Processor (Big) (VOPB)"]
pub struct MmuVopb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MmuVopb {}
impl MmuVopb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff90_3f00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MmuVopb {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MmuVopb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MmuVopb").finish()
    }
}
#[doc = "Registers of Memory Management Unit (MMU) for Visual Output Processor (Big) (VOPB)"]
pub use self::mmu as mmu_vopb;
#[doc = "Registers of Memory Management Unit (MMU) for Visual Output Processor (Little) (VOPL)"]
pub struct MmuVopl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MmuVopl {}
impl MmuVopl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff8f_3f00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MmuVopl {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MmuVopl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MmuVopl").finish()
    }
}
#[doc = "Registers of Memory Management Unit (MMU) for Visual Output Processor (Little) (VOPL)"]
pub use self::mmu as mmu_vopl;
#[doc = "Registers of Memory Management Unit (MMU) for Video Processing Unit (VPU)"]
pub struct MmuVpu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MmuVpu {}
impl MmuVpu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmu::RegisterBlock = 0xff65_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MmuVpu {
    type Target = mmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MmuVpu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MmuVpu").finish()
    }
}
#[doc = "Registers of Memory Management Unit (MMU) for Video Processing Unit (VPU)"]
pub use self::mmu as mmu_vpu;
#[doc = "Memory Schedule (MSCH) Registers"]
pub struct Msch {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msch {}
impl Msch {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msch::RegisterBlock = 0xffa8_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msch::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msch {
    type Target = msch::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msch {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msch").finish()
    }
}
#[doc = "Memory Schedule (MSCH) Registers"]
pub mod msch;
#[doc = "Memory Schedule (MSCH) 0 Registers"]
pub struct Msch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msch0 {}
impl Msch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msch::RegisterBlock = 0xffa8_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msch::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msch0 {
    type Target = msch::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msch0").finish()
    }
}
#[doc = "Memory Schedule (MSCH) 0 Registers"]
pub use self::msch as msch0;
#[doc = "Memory Schedule (MSCH) 1 Registers"]
pub struct Msch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msch1 {}
impl Msch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msch::RegisterBlock = 0xffa8_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msch::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msch1 {
    type Target = msch::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msch1").finish()
    }
}
#[doc = "Memory Schedule (MSCH) 1 Registers"]
pub use self::msch as msch1;
#[doc = "PCIe Client Registers"]
pub struct PcieClient {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PcieClient {}
impl PcieClient {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcie_client::RegisterBlock = 0xfd00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcie_client::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PcieClient {
    type Target = pcie_client::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PcieClient {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PcieClient").finish()
    }
}
#[doc = "PCIe Client Registers"]
pub mod pcie_client;
#[doc = "PCIe Core Registers"]
pub struct PcieCore {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PcieCore {}
impl PcieCore {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcie_core::RegisterBlock = 0xfd80_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcie_core::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PcieCore {
    type Target = pcie_core::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PcieCore {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PcieCore").finish()
    }
}
#[doc = "PCIe Core Registers"]
pub mod pcie_core;
#[doc = "Power Management Unit (PMU) Registers"]
pub struct Pmu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmu {}
impl Pmu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmu::RegisterBlock = 0xff31_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmu {
    type Target = pmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmu").finish()
    }
}
#[doc = "Power Management Unit (PMU) Registers"]
pub mod pmu;
#[doc = "Power Management Unit Clock and Reset Unit (PMUCRU) Registers"]
pub struct Pmucru {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmucru {}
impl Pmucru {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmucru::RegisterBlock = 0xff75_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmucru::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmucru {
    type Target = pmucru::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmucru {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmucru").finish()
    }
}
#[doc = "Power Management Unit Clock and Reset Unit (PMUCRU) Registers"]
pub mod pmucru;
#[doc = "Power Management Unit General Register File (PMUGRF) Registers"]
pub struct Pmugrf {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmugrf {}
impl Pmugrf {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmugrf::RegisterBlock = 0xff32_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmugrf::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmugrf {
    type Target = pmugrf::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmugrf {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmugrf").finish()
    }
}
#[doc = "Power Management Unit General Register File (PMUGRF) Registers"]
pub mod pmugrf;
#[doc = "VPU Prefetch Cache Registers"]
pub struct PrefCache {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PrefCache {}
impl PrefCache {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pref_cache::RegisterBlock = 0xff66_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pref_cache::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PrefCache {
    type Target = pref_cache::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PrefCache {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PrefCache").finish()
    }
}
#[doc = "VPU Prefetch Cache Registers"]
pub mod pref_cache;
#[doc = "RKVDEC Chroma Prefetch Cache Control Registers"]
pub struct PrefCacheRkvdecChroma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PrefCacheRkvdecChroma {}
impl PrefCacheRkvdecChroma {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pref_cache::RegisterBlock = 0xff66_0440 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pref_cache::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PrefCacheRkvdecChroma {
    type Target = pref_cache::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PrefCacheRkvdecChroma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PrefCacheRkvdecChroma").finish()
    }
}
#[doc = "RKVDEC Chroma Prefetch Cache Control Registers"]
pub use self::pref_cache as pref_cache_rkvdec_chroma;
#[doc = "RKVDEC Luma Prefetch Cache Control Registers"]
pub struct PrefCacheRkvdecLuma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PrefCacheRkvdecLuma {}
impl PrefCacheRkvdecLuma {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pref_cache::RegisterBlock = 0xff66_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pref_cache::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PrefCacheRkvdecLuma {
    type Target = pref_cache::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PrefCacheRkvdecLuma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PrefCacheRkvdecLuma").finish()
    }
}
#[doc = "RKVDEC Luma Prefetch Cache Control Registers"]
pub use self::pref_cache as pref_cache_rkvdec_luma;
#[doc = "VPU Prefetch Cache Control Registers"]
pub struct PrefCacheVpu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PrefCacheVpu {}
impl PrefCacheVpu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pref_cache::RegisterBlock = 0xff65_0c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pref_cache::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PrefCacheVpu {
    type Target = pref_cache::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PrefCacheVpu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PrefCacheVpu").finish()
    }
}
#[doc = "VPU Prefetch Cache Control Registers"]
pub use self::pref_cache as pref_cache_vpu;
#[doc = "Probe Registers"]
pub struct Probe {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Probe {}
impl Probe {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Probe {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Probe {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Probe").finish()
    }
}
#[doc = "Probe Registers"]
pub mod probe;
#[doc = "Registers for the probe covering paths from the CCI_M1 to the memory schedule 0"]
pub struct ProbeCciMsch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeCciMsch0 {}
impl ProbeCciMsch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeCciMsch0 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeCciMsch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeCciMsch0").finish()
    }
}
#[doc = "Registers for the probe covering paths from the CCI_M1 to the memory schedule 0"]
pub use self::probe as probe_cci_msch0;
#[doc = "Registers for the probe covering paths from the CCI_M1 to the memory schedule 1"]
pub struct ProbeCciMsch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeCciMsch1 {}
impl ProbeCciMsch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeCciMsch1 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeCciMsch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeCciMsch1").finish()
    }
}
#[doc = "Registers for the probe covering paths from the CCI_M1 to the memory schedule 1"]
pub use self::probe as probe_cci_msch1;
#[doc = "Registers for the probe covering paths from the GPU to the memory schedule 0"]
pub struct ProbeGpuMsch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeGpuMsch0 {}
impl ProbeGpuMsch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_6400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeGpuMsch0 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeGpuMsch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeGpuMsch0").finish()
    }
}
#[doc = "Registers for the probe covering paths from the GPU to the memory schedule 0"]
pub use self::probe as probe_gpu_msch0;
#[doc = "Registers for the probe covering paths from the GPU to the memory schedule 1"]
pub struct ProbeGpuMsch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeGpuMsch1 {}
impl ProbeGpuMsch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_e400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeGpuMsch1 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeGpuMsch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeGpuMsch1").finish()
    }
}
#[doc = "Registers for the probe covering paths from the GPU to the memory schedule 1"]
pub use self::probe as probe_gpu_msch1;
#[doc = "Registers for the probe covering paths from the perihp master NIU to the memory schedule 0"]
pub struct ProbePerihpMsch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbePerihpMsch0 {}
impl ProbePerihpMsch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_6800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbePerihpMsch0 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbePerihpMsch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbePerihpMsch0").finish()
    }
}
#[doc = "Registers for the probe covering paths from the perihp master NIU to the memory schedule 0"]
pub use self::probe as probe_perihp_msch0;
#[doc = "Registers for the probe covering paths from the perihp master NIU to the memory schedule 1"]
pub struct ProbePerihpMsch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbePerihpMsch1 {}
impl ProbePerihpMsch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_e800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbePerihpMsch1 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbePerihpMsch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbePerihpMsch1").finish()
    }
}
#[doc = "Registers for the probe covering paths from the perihp master NIU to the memory schedule 1"]
pub use self::probe as probe_perihp_msch1;
#[doc = "Registers for the probe covering paths from the perilp master NIU, debug and CCI_M0 to the memory schedule 0"]
pub struct ProbePerilpMsch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbePerilpMsch0 {}
impl ProbePerilpMsch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_6c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbePerilpMsch0 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbePerilpMsch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbePerilpMsch0").finish()
    }
}
#[doc = "Registers for the probe covering paths from the perilp master NIU, debug and CCI_M0 to the memory schedule 0"]
pub use self::probe as probe_perilp_msch0;
#[doc = "Registers for the probe covering paths from the perilp master NIU, debug and CCI_M0 to the memory schedule 1"]
pub struct ProbePerilpMsch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbePerilpMsch1 {}
impl ProbePerilpMsch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_ec00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbePerilpMsch1 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbePerilpMsch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbePerilpMsch1").finish()
    }
}
#[doc = "Registers for the probe covering paths from the perilp master NIU, debug and CCI_M0 to the memory schedule 1"]
pub use self::probe as probe_perilp_msch1;
#[doc = "Registers for the probe covering paths from video to the memory schedule 0"]
pub struct ProbeVideoMsch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeVideoMsch0 {}
impl ProbeVideoMsch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeVideoMsch0 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeVideoMsch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeVideoMsch0").finish()
    }
}
#[doc = "Registers for the probe covering paths from video to the memory schedule 0"]
pub use self::probe as probe_video_msch0;
#[doc = "Registers for the probe covering paths from video to the memory schedule 1"]
pub struct ProbeVideoMsch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeVideoMsch1 {}
impl ProbeVideoMsch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeVideoMsch1 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeVideoMsch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeVideoMsch1").finish()
    }
}
#[doc = "Registers for the probe covering paths from video to the memory schedule 1"]
pub use self::probe as probe_video_msch1;
#[doc = "Registers for the probe covering paths from the IEP, ISP0 and VOP-BIG to the memory schedule 0"]
pub struct ProbeVio0Msch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeVio0Msch0 {}
impl ProbeVio0Msch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_7400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeVio0Msch0 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeVio0Msch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeVio0Msch0").finish()
    }
}
#[doc = "Registers for the probe covering paths from the IEP, ISP0 and VOP-BIG to the memory schedule 0"]
pub use self::probe as probe_vio0_msch0;
#[doc = "Registers for the probe covering paths from the IEP, ISP0 and VOP-BIG to the memory schedule 1"]
pub struct ProbeVio0Msch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeVio0Msch1 {}
impl ProbeVio0Msch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_f400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeVio0Msch1 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeVio0Msch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeVio0Msch1").finish()
    }
}
#[doc = "Registers for the probe covering paths from the IEP, ISP0 and VOP-BIG to the memory schedule 1"]
pub use self::probe as probe_vio0_msch1;
#[doc = "Registers for the probe covering paths from the RGA, ISP1, VOP-LITTLE and HDCP to the memory schedule 0"]
pub struct ProbeVio1Msch0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeVio1Msch0 {}
impl ProbeVio1Msch0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_7800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeVio1Msch0 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeVio1Msch0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeVio1Msch0").finish()
    }
}
#[doc = "Registers for the probe covering paths from the RGA, ISP1, VOP-LITTLE and HDCP to the memory schedule 0"]
pub use self::probe as probe_vio1_msch0;
#[doc = "Registers for the probe covering paths from the RGA, ISP1, VOP-LITTLE and HDCP to the memory schedule 1"]
pub struct ProbeVio1Msch1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ProbeVio1Msch1 {}
impl ProbeVio1Msch1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const probe::RegisterBlock = 0xffa8_f800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const probe::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ProbeVio1Msch1 {
    type Target = probe::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ProbeVio1Msch1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ProbeVio1Msch1").finish()
    }
}
#[doc = "Registers for the probe covering paths from the RGA, ISP1, VOP-LITTLE and HDCP to the memory schedule 1"]
pub use self::probe as probe_vio1_msch1;
#[doc = "Pulse Width Modulation (PWM) Registers"]
pub struct Pwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm {}
impl Pwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm::RegisterBlock = 0xff42_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm {
    type Target = pwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm").finish()
    }
}
#[doc = "Pulse Width Modulation (PWM) Registers"]
pub mod pwm;
#[doc = "Quality of Service (QOS) Registers"]
pub struct Qos {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Qos {}
impl Qos {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa5_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Qos {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Qos {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Qos").finish()
    }
}
#[doc = "Quality of Service (QOS) Registers"]
pub mod qos;
#[doc = "QoS Registers for CCI_M0"]
pub struct QosCciM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosCciM0 {}
impl QosCciM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa5_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosCciM0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosCciM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosCciM0").finish()
    }
}
#[doc = "QoS Registers for CCI_M0"]
pub use self::qos as qos_cci_m0;
#[doc = "QoS Registers for CCI_M1"]
pub struct QosCciM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosCciM1 {}
impl QosCciM1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffad_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosCciM1 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosCciM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosCciM1").finish()
    }
}
#[doc = "QoS Registers for CCI_M1"]
pub use self::qos as qos_cci_m1;
#[doc = "QoS Registers for CRYPTO0"]
pub struct QosCrypto0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosCrypto0 {}
impl QosCrypto0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_4100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosCrypto0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosCrypto0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosCrypto0").finish()
    }
}
#[doc = "QoS Registers for CRYPTO0"]
pub use self::qos as qos_crypto0;
#[doc = "QoS Registers for CRYPTO1"]
pub struct QosCrypto1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosCrypto1 {}
impl QosCrypto1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_4080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosCrypto1 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosCrypto1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosCrypto1").finish()
    }
}
#[doc = "QoS Registers for CRYPTO1"]
pub use self::qos as qos_crypto1;
#[doc = "QoS Registers for DCF"]
pub struct QosDcf {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosDcf {}
impl QosDcf {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_4180 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosDcf {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosDcf {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosDcf").finish()
    }
}
#[doc = "QoS Registers for DCF"]
pub use self::qos as qos_dcf;
#[doc = "QoS Registers for DMAC0"]
pub struct QosDmac0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosDmac0 {}
impl QosDmac0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosDmac0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosDmac0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosDmac0").finish()
    }
}
#[doc = "QoS Registers for DMAC0"]
pub use self::qos as qos_dmac0;
#[doc = "QoS Registers for DMAC1"]
pub struct QosDmac1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosDmac1 {}
impl QosDmac1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_4280 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosDmac1 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosDmac1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosDmac1").finish()
    }
}
#[doc = "QoS Registers for DMAC1"]
pub use self::qos as qos_dmac1;
#[doc = "QoS Registers for EMMC"]
pub struct QosEmmc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosEmmc {}
impl QosEmmc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa5_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosEmmc {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosEmmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosEmmc").finish()
    }
}
#[doc = "QoS Registers for EMMC"]
pub use self::qos as qos_emmc;
#[doc = "QoS Registers for GIC"]
pub struct QosGic {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosGic {}
impl QosGic {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa7_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosGic {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosGic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosGic").finish()
    }
}
#[doc = "QoS Registers for GIC"]
pub use self::qos as qos_gic;
#[doc = "QoS Registers for GMAC"]
pub struct QosGmac {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosGmac {}
impl QosGmac {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa5_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosGmac {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosGmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosGmac").finish()
    }
}
#[doc = "QoS Registers for GMAC"]
pub use self::qos as qos_gmac;
#[doc = "QoS Registers for GPU"]
pub struct QosGpu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosGpu {}
impl QosGpu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffae_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosGpu {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosGpu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosGpu").finish()
    }
}
#[doc = "QoS Registers for GPU"]
pub use self::qos as qos_gpu;
#[doc = "QoS Registers for HDCP"]
pub struct QosHdcp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosHdcp {}
impl QosHdcp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa9_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosHdcp {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosHdcp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosHdcp").finish()
    }
}
#[doc = "QoS Registers for HDCP"]
pub use self::qos as qos_hdcp;
#[doc = "QoS Registers for HSIC"]
pub struct QosHsic {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosHsic {}
impl QosHsic {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosHsic {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosHsic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosHsic").finish()
    }
}
#[doc = "QoS Registers for HSIC"]
pub use self::qos as qos_hsic;
#[doc = "QoS Registers for IEP"]
pub struct QosIep {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosIep {}
impl QosIep {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa9_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosIep {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosIep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosIep").finish()
    }
}
#[doc = "QoS Registers for IEP"]
pub use self::qos as qos_iep;
#[doc = "QoS Registers for ISP0_M0"]
pub struct QosIsp0M0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosIsp0M0 {}
impl QosIsp0M0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffaa_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosIsp0M0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosIsp0M0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosIsp0M0").finish()
    }
}
#[doc = "QoS Registers for ISP0_M0"]
pub use self::qos as qos_isp0_m0;
#[doc = "QoS Registers for ISP0_M1"]
pub struct QosIsp0M1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosIsp0M1 {}
impl QosIsp0M1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffaa_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosIsp0M1 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosIsp0M1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosIsp0M1").finish()
    }
}
#[doc = "QoS Registers for ISP0_M1"]
pub use self::qos as qos_isp0_m1;
#[doc = "QoS Registers for ISP1_M0"]
pub struct QosIsp1M0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosIsp1M0 {}
impl QosIsp1M0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffaa_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosIsp1M0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosIsp1M0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosIsp1M0").finish()
    }
}
#[doc = "QoS Registers for ISP1_M0"]
pub use self::qos as qos_isp1_m0;
#[doc = "QoS Registers for ISP1_M1"]
pub struct QosIsp1M1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosIsp1M1 {}
impl QosIsp1M1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffaa_8080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosIsp1M1 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosIsp1M1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosIsp1M1").finish()
    }
}
#[doc = "QoS Registers for ISP1_M1"]
pub use self::qos as qos_isp1_m1;
#[doc = "QoS Registers for PCIE"]
pub struct QosPcie {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosPcie {}
impl QosPcie {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosPcie {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosPcie {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosPcie").finish()
    }
}
#[doc = "QoS Registers for PCIE"]
pub use self::qos as qos_pcie;
#[doc = "QoS Registers for PERIHP_NSP"]
pub struct QosPerihpNsp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosPerihpNsp {}
impl QosPerihpNsp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffad_8080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosPerihpNsp {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosPerihpNsp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosPerihpNsp").finish()
    }
}
#[doc = "QoS Registers for PERIHP_NSP"]
pub use self::qos as qos_perihp_nsp;
#[doc = "QoS Registers for PERILPSLV_NSP"]
pub struct QosPerilpslvNsp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosPerilpslvNsp {}
impl QosPerilpslvNsp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffad_8100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosPerilpslvNsp {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosPerilpslvNsp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosPerilpslvNsp").finish()
    }
}
#[doc = "QoS Registers for PERILPSLV_NSP"]
pub use self::qos as qos_perilpslv_nsp;
#[doc = "QoS Registers for PERILP_NSP"]
pub struct QosPerilpNsp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosPerilpNsp {}
impl QosPerilpNsp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffad_8180 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosPerilpNsp {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosPerilpNsp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosPerilpNsp").finish()
    }
}
#[doc = "QoS Registers for PERILP_NSP"]
pub use self::qos as qos_perilp_nsp;
#[doc = "QoS Registers for PERI_CM0"]
pub struct QosPeriCm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosPeriCm0 {}
impl QosPeriCm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_4300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosPeriCm0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosPeriCm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosPeriCm0").finish()
    }
}
#[doc = "QoS Registers for PERI_CM0"]
pub use self::qos as qos_peri_cm0;
#[doc = "QoS Registers for PMU_CM0"]
pub struct QosPmuCm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosPmuCm0 {}
impl QosPmuCm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosPmuCm0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosPmuCm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosPmuCm0").finish()
    }
}
#[doc = "QoS Registers for PMU_CM0"]
pub use self::qos as qos_pmu_cm0;
#[doc = "QoS Registers for RGA_R"]
pub struct QosRgaR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosRgaR {}
impl QosRgaR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffab_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosRgaR {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosRgaR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosRgaR").finish()
    }
}
#[doc = "QoS Registers for RGA_R"]
pub use self::qos as qos_rga_r;
#[doc = "QoS Registers for RGA_W"]
pub struct QosRgaW {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosRgaW {}
impl QosRgaW {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffab_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosRgaW {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosRgaW {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosRgaW").finish()
    }
}
#[doc = "QoS Registers for RGA_W"]
pub use self::qos as qos_rga_w;
#[doc = "QoS Registers for SDIO"]
pub struct QosSdio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosSdio {}
impl QosSdio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa7_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosSdio {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosSdio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosSdio").finish()
    }
}
#[doc = "QoS Registers for SDIO"]
pub use self::qos as qos_sdio;
#[doc = "QoS Registers for SDMMC"]
pub struct QosSdmmc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosSdmmc {}
impl QosSdmmc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa7_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosSdmmc {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosSdmmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosSdmmc").finish()
    }
}
#[doc = "QoS Registers for SDMMC"]
pub use self::qos as qos_sdmmc;
#[doc = "QoS Registers for USB_HOST0"]
pub struct QosUsbHost0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosUsbHost0 {}
impl QosUsbHost0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosUsbHost0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosUsbHost0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosUsbHost0").finish()
    }
}
#[doc = "QoS Registers for USB_HOST0"]
pub use self::qos as qos_usb_host0;
#[doc = "QoS Registers for USB_HOST1"]
pub struct QosUsbHost1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosUsbHost1 {}
impl QosUsbHost1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa6_0180 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosUsbHost1 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosUsbHost1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosUsbHost1").finish()
    }
}
#[doc = "QoS Registers for USB_HOST1"]
pub use self::qos as qos_usb_host1;
#[doc = "QoS Registers for USB_OTG0"]
pub struct QosUsbOtg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosUsbOtg0 {}
impl QosUsbOtg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa7_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosUsbOtg0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosUsbOtg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosUsbOtg0").finish()
    }
}
#[doc = "QoS Registers for USB_OTG0"]
pub use self::qos as qos_usb_otg0;
#[doc = "QoS Registers for USB_OTG1"]
pub struct QosUsbOtg1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosUsbOtg1 {}
impl QosUsbOtg1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffa7_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosUsbOtg1 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosUsbOtg1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosUsbOtg1").finish()
    }
}
#[doc = "QoS Registers for USB_OTG1"]
pub use self::qos as qos_usb_otg1;
#[doc = "QoS Registers for VIDEO_M0"]
pub struct QosVideoM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosVideoM0 {}
impl QosVideoM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffab_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosVideoM0 {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosVideoM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosVideoM0").finish()
    }
}
#[doc = "QoS Registers for VIDEO_M0"]
pub use self::qos as qos_video_m0;
#[doc = "QoS Registers for VIDEO_M1_R"]
pub struct QosVideoM1R {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosVideoM1R {}
impl QosVideoM1R {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffac_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosVideoM1R {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosVideoM1R {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosVideoM1R").finish()
    }
}
#[doc = "QoS Registers for VIDEO_M1_R"]
pub use self::qos as qos_video_m1_r;
#[doc = "QoS Registers for VIDEO_M1_W"]
pub struct QosVideoM1W {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosVideoM1W {}
impl QosVideoM1W {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffac_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosVideoM1W {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosVideoM1W {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosVideoM1W").finish()
    }
}
#[doc = "QoS Registers for VIDEO_M1_W"]
pub use self::qos as qos_video_m1_w;
#[doc = "QoS Registers for VOP-BIG_R"]
pub struct QosVopBigR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosVopBigR {}
impl QosVopBigR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffac_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosVopBigR {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosVopBigR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosVopBigR").finish()
    }
}
#[doc = "QoS Registers for VOP-BIG_R"]
pub use self::qos as qos_vop_big_r;
#[doc = "QoS Registers for VOP-BIG_W"]
pub struct QosVopBigW {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosVopBigW {}
impl QosVopBigW {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffac_8080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosVopBigW {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosVopBigW {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosVopBigW").finish()
    }
}
#[doc = "QoS Registers for VOP-BIG_W"]
pub use self::qos as qos_vop_big_w;
#[doc = "QoS Registers for VOP-LITTLE"]
pub struct QosVopLittle {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QosVopLittle {}
impl QosVopLittle {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qos::RegisterBlock = 0xffad_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QosVopLittle {
    type Target = qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QosVopLittle {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QosVopLittle").finish()
    }
}
#[doc = "QoS Registers for VOP-LITTLE"]
pub use self::qos as qos_vop_little;
#[doc = "Rockchip Graphics Accelerator 2 (RGA2) Registers"]
pub struct Rga2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rga2 {}
impl Rga2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rga2::RegisterBlock = 0xff68_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rga2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rga2 {
    type Target = rga2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rga2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rga2").finish()
    }
}
#[doc = "Rockchip Graphics Accelerator 2 (RGA2) Registers"]
pub mod rga2;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) Registers"]
pub struct Rki2c {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c {}
impl Rki2c {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff3c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) Registers"]
pub mod rki2c;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 0 Registers"]
pub struct Rki2c0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c0 {}
impl Rki2c0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff3c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c0 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c0").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 0 Registers"]
pub use self::rki2c as rki2c0;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 1 Registers"]
pub struct Rki2c1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c1 {}
impl Rki2c1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff11_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c1 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c1").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 1 Registers"]
pub use self::rki2c as rki2c1;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 2 Registers"]
pub struct Rki2c2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c2 {}
impl Rki2c2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff12_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c2 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c2").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 2 Registers"]
pub use self::rki2c as rki2c2;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 3 Registers"]
pub struct Rki2c3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c3 {}
impl Rki2c3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff13_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c3 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c3").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 3 Registers"]
pub use self::rki2c as rki2c3;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 4 Registers"]
pub struct Rki2c4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c4 {}
impl Rki2c4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff3d_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c4 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c4").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 4 Registers"]
pub use self::rki2c as rki2c4;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 5 Registers"]
pub struct Rki2c5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c5 {}
impl Rki2c5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff14_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c5 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c5").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 5 Registers"]
pub use self::rki2c as rki2c5;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 6 Registers"]
pub struct Rki2c6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c6 {}
impl Rki2c6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff15_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c6 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c6").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 6 Registers"]
pub use self::rki2c as rki2c6;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 7 Registers"]
pub struct Rki2c7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c7 {}
impl Rki2c7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff16_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c7 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c7").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 7 Registers"]
pub use self::rki2c as rki2c7;
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 8 Registers"]
pub struct Rki2c8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rki2c8 {}
impl Rki2c8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rki2c::RegisterBlock = 0xff3e_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rki2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rki2c8 {
    type Target = rki2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rki2c8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rki2c8").finish()
    }
}
#[doc = "Rockchip Inter-Integrated Circuit (RKI2C) 8 Registers"]
pub use self::rki2c as rki2c8;
#[doc = "Rockchip Video Decoder (RKVDEC) Registers"]
pub struct Rkvdec {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rkvdec {}
impl Rkvdec {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rkvdec::RegisterBlock = 0xff66_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rkvdec::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rkvdec {
    type Target = rkvdec::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rkvdec {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rkvdec").finish()
    }
}
#[doc = "Rockchip Video Decoder (RKVDEC) Registers"]
pub mod rkvdec;
#[doc = "Successive Approximation Register Analog-to-Digital Converter (SARADC) Registers"]
pub struct Saradc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Saradc {}
impl Saradc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const saradc::RegisterBlock = 0xff10_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const saradc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Saradc {
    type Target = saradc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Saradc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Saradc").finish()
    }
}
#[doc = "Successive Approximation Register Analog-to-Digital Converter (SARADC) Registers"]
pub mod saradc;
#[doc = "Secure Digital MultiMedia Card (SDMMC) Registers"]
pub struct Sdmmc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sdmmc {}
impl Sdmmc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sdmmc::RegisterBlock = 0xfe32_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sdmmc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sdmmc {
    type Target = sdmmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sdmmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sdmmc").finish()
    }
}
#[doc = "Secure Digital MultiMedia Card (SDMMC) Registers"]
pub mod sdmmc;
#[doc = "Sony/Philips Digital Interface (SPDIF) Registers"]
pub struct Spdif {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spdif {}
impl Spdif {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spdif::RegisterBlock = 0xff87_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spdif::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spdif {
    type Target = spdif::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spdif {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spdif").finish()
    }
}
#[doc = "Sony/Philips Digital Interface (SPDIF) Registers"]
pub mod spdif;
#[doc = "Serial Peripheral Interface (SPI) Registers"]
pub struct Spi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi {}
impl Spi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi::RegisterBlock = 0xff1c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi {
    type Target = spi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) Registers"]
pub mod spi;
#[doc = "Serial Peripheral Interface (SPI) 0 Registers"]
pub struct Spi0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi0 {}
impl Spi0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi::RegisterBlock = 0xff1c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi0 {
    type Target = spi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi0").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) 0 Registers"]
pub use self::spi as spi0;
#[doc = "Serial Peripheral Interface (SPI) 1 Registers"]
pub struct Spi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi1 {}
impl Spi1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi::RegisterBlock = 0xff1d_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi1 {
    type Target = spi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi1").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) 1 Registers"]
pub use self::spi as spi1;
#[doc = "Serial Peripheral Interface (SPI) 2 Registers"]
pub struct Spi2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi2 {}
impl Spi2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi::RegisterBlock = 0xff1e_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi2 {
    type Target = spi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi2").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) 2 Registers"]
pub use self::spi as spi2;
#[doc = "Serial Peripheral Interface (SPI) 3 Registers"]
pub struct Spi3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi3 {}
impl Spi3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi::RegisterBlock = 0xff35_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi3 {
    type Target = spi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi3").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) 3 Registers"]
pub use self::spi as spi3;
#[doc = "Serial Peripheral Interface (SPI) 4 Registers"]
pub struct Spi4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi4 {}
impl Spi4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi::RegisterBlock = 0xff1f_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi4 {
    type Target = spi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi4").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) 4 Registers"]
pub use self::spi as spi4;
#[doc = "Serial Peripheral Interface (SPI) 5 Registers"]
pub struct Spi5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi5 {}
impl Spi5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi::RegisterBlock = 0xff20_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi5 {
    type Target = spi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi5").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) 5 Registers"]
pub use self::spi as spi5;
#[doc = "Timer Registers"]
pub struct Timer {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer {}
impl Timer {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer").finish()
    }
}
#[doc = "Timer Registers"]
pub mod timer;
#[doc = "Timer 0 Registers"]
pub struct Timer0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0 {}
impl Timer0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0").finish()
    }
}
#[doc = "Timer 0 Registers"]
pub use self::timer as timer0;
#[doc = "Timer 1 Registers"]
pub struct Timer1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer1 {}
impl Timer1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_0020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer1 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer1").finish()
    }
}
#[doc = "Timer 1 Registers"]
pub use self::timer as timer1;
#[doc = "Timer 10 Registers"]
pub struct Timer10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer10 {}
impl Timer10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_8080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer10 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer10").finish()
    }
}
#[doc = "Timer 10 Registers"]
pub use self::timer as timer10;
#[doc = "Timer 11 Registers"]
pub struct Timer11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer11 {}
impl Timer11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_80a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer11 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer11").finish()
    }
}
#[doc = "Timer 11 Registers"]
pub use self::timer as timer11;
#[doc = "Timer 2 Registers"]
pub struct Timer2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer2 {}
impl Timer2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_0040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer2 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer2").finish()
    }
}
#[doc = "Timer 2 Registers"]
pub use self::timer as timer2;
#[doc = "Timer 3 Registers"]
pub struct Timer3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer3 {}
impl Timer3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_0060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer3 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer3").finish()
    }
}
#[doc = "Timer 3 Registers"]
pub use self::timer as timer3;
#[doc = "Timer 4 Registers"]
pub struct Timer4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer4 {}
impl Timer4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer4 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer4").finish()
    }
}
#[doc = "Timer 4 Registers"]
pub use self::timer as timer4;
#[doc = "Timer 5 Registers"]
pub struct Timer5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer5 {}
impl Timer5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_00a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer5 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer5").finish()
    }
}
#[doc = "Timer 5 Registers"]
pub use self::timer as timer5;
#[doc = "Timer 6 Registers"]
pub struct Timer6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer6 {}
impl Timer6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer6 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer6").finish()
    }
}
#[doc = "Timer 6 Registers"]
pub use self::timer as timer6;
#[doc = "Timer 7 Registers"]
pub struct Timer7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer7 {}
impl Timer7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_8020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer7 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer7").finish()
    }
}
#[doc = "Timer 7 Registers"]
pub use self::timer as timer7;
#[doc = "Timer 8 Registers"]
pub struct Timer8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer8 {}
impl Timer8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_8040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer8 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer8").finish()
    }
}
#[doc = "Timer 8 Registers"]
pub use self::timer as timer8;
#[doc = "Timer 9 Registers"]
pub struct Timer9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer9 {}
impl Timer9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff85_8060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer9 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer9").finish()
    }
}
#[doc = "Timer 9 Registers"]
pub use self::timer as timer9;
#[doc = "Power Management Unit Timer 0 Registers"]
pub struct Pmutimer0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmutimer0 {}
impl Pmutimer0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff36_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmutimer0 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmutimer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmutimer0").finish()
    }
}
#[doc = "Power Management Unit Timer 0 Registers"]
pub use self::timer as pmutimer0;
#[doc = "Power Management Unit Timer 1 Registers"]
pub struct Pmutimer1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmutimer1 {}
impl Pmutimer1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff36_0020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmutimer1 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmutimer1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmutimer1").finish()
    }
}
#[doc = "Power Management Unit Timer 1 Registers"]
pub use self::timer as pmutimer1;
#[doc = "Secure Timer 0 Registers"]
pub struct Stimer0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer0 {}
impl Stimer0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer0 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer0").finish()
    }
}
#[doc = "Secure Timer 0 Registers"]
pub use self::timer as stimer0;
#[doc = "Secure Timer 1 Registers"]
pub struct Stimer1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer1 {}
impl Stimer1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_0020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer1 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer1").finish()
    }
}
#[doc = "Secure Timer 1 Registers"]
pub use self::timer as stimer1;
#[doc = "Secure Timer 10 Registers"]
pub struct Stimer10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer10 {}
impl Stimer10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_8080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer10 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer10").finish()
    }
}
#[doc = "Secure Timer 10 Registers"]
pub use self::timer as stimer10;
#[doc = "Secure Timer 11 Registers"]
pub struct Stimer11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer11 {}
impl Stimer11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_80a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer11 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer11").finish()
    }
}
#[doc = "Secure Timer 11 Registers"]
pub use self::timer as stimer11;
#[doc = "Secure Timer 2 Registers"]
pub struct Stimer2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer2 {}
impl Stimer2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_0040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer2 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer2").finish()
    }
}
#[doc = "Secure Timer 2 Registers"]
pub use self::timer as stimer2;
#[doc = "Secure Timer 3 Registers"]
pub struct Stimer3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer3 {}
impl Stimer3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_0060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer3 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer3").finish()
    }
}
#[doc = "Secure Timer 3 Registers"]
pub use self::timer as stimer3;
#[doc = "Secure Timer 4 Registers"]
pub struct Stimer4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer4 {}
impl Stimer4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer4 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer4").finish()
    }
}
#[doc = "Secure Timer 4 Registers"]
pub use self::timer as stimer4;
#[doc = "Secure Timer 5 Registers"]
pub struct Stimer5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer5 {}
impl Stimer5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_00a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer5 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer5").finish()
    }
}
#[doc = "Secure Timer 5 Registers"]
pub use self::timer as stimer5;
#[doc = "Secure Timer 6 Registers"]
pub struct Stimer6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer6 {}
impl Stimer6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer6 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer6").finish()
    }
}
#[doc = "Secure Timer 6 Registers"]
pub use self::timer as stimer6;
#[doc = "Secure Timer 7 Registers"]
pub struct Stimer7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer7 {}
impl Stimer7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_8020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer7 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer7").finish()
    }
}
#[doc = "Secure Timer 7 Registers"]
pub use self::timer as stimer7;
#[doc = "Secure Timer 8 Registers"]
pub struct Stimer8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer8 {}
impl Stimer8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_8040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer8 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer8").finish()
    }
}
#[doc = "Secure Timer 8 Registers"]
pub use self::timer as stimer8;
#[doc = "Secure Timer 9 Registers"]
pub struct Stimer9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer9 {}
impl Stimer9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0xff86_8060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer9 {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer9").finish()
    }
}
#[doc = "Secure Timer 9 Registers"]
pub use self::timer as stimer9;
#[doc = "Temperature Sensor Analog-to-Digital Converter (TSADC) Registers"]
pub struct Tsadc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tsadc {}
impl Tsadc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tsadc::RegisterBlock = 0xff26_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tsadc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tsadc {
    type Target = tsadc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tsadc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tsadc").finish()
    }
}
#[doc = "Temperature Sensor Analog-to-Digital Converter (TSADC) Registers"]
pub mod tsadc;
#[doc = "Type-C Power Delivery (TYPEC_PD) Registers"]
pub struct TypecPd {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TypecPd {}
impl TypecPd {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const typec_pd::RegisterBlock = 0xff7a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const typec_pd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TypecPd {
    type Target = typec_pd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TypecPd {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TypecPd").finish()
    }
}
#[doc = "Type-C Power Delivery (TYPEC_PD) Registers"]
pub mod typec_pd;
#[doc = "Type-C Power Delivery (TYPEC_PD) 0 Registers"]
pub struct TypecPd0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TypecPd0 {}
impl TypecPd0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const typec_pd::RegisterBlock = 0xff7a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const typec_pd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TypecPd0 {
    type Target = typec_pd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TypecPd0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TypecPd0").finish()
    }
}
#[doc = "Type-C Power Delivery (TYPEC_PD) 0 Registers"]
pub use self::typec_pd as typec_pd0;
#[doc = "Type-C Power Delivery (TYPEC_PD) 1 Registers"]
pub struct TypecPd1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TypecPd1 {}
impl TypecPd1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const typec_pd::RegisterBlock = 0xff7b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const typec_pd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TypecPd1 {
    type Target = typec_pd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TypecPd1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TypecPd1").finish()
    }
}
#[doc = "Type-C Power Delivery (TYPEC_PD) 1 Registers"]
pub use self::typec_pd as typec_pd1;
#[doc = "Type-C PHY Registers"]
pub struct TypecPhy {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TypecPhy {}
impl TypecPhy {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const typec_phy::RegisterBlock = 0xff7c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const typec_phy::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TypecPhy {
    type Target = typec_phy::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TypecPhy {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TypecPhy").finish()
    }
}
#[doc = "Type-C PHY Registers"]
pub mod typec_phy;
#[doc = "Type-C PHY 0 Registers"]
pub struct TypecPhy0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TypecPhy0 {}
impl TypecPhy0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const typec_phy::RegisterBlock = 0xff7c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const typec_phy::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TypecPhy0 {
    type Target = typec_phy::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TypecPhy0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TypecPhy0").finish()
    }
}
#[doc = "Type-C PHY 0 Registers"]
pub use self::typec_phy as typec_phy0;
#[doc = "Type-C PHY 1 Registers"]
pub struct TypecPhy1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TypecPhy1 {}
impl TypecPhy1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const typec_phy::RegisterBlock = 0xff80_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const typec_phy::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TypecPhy1 {
    type Target = typec_phy::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TypecPhy1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TypecPhy1").finish()
    }
}
#[doc = "Type-C PHY 1 Registers"]
pub use self::typec_phy as typec_phy1;
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) Registers"]
pub struct Uart {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart {}
impl Uart {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xff18_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) Registers"]
pub mod uart;
#[doc = "Universal Asynchronous Receiver/Transmitter 0 (UART0) Registers"]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart0 {}
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xff18_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart0 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter 0 (UART0) Registers"]
pub use self::uart as uart0;
#[doc = "Universal Asynchronous Receiver/Transmitter 1 (UART1) Registers"]
pub struct Uart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart1 {}
impl Uart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xff19_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart1 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter 1 (UART1) Registers"]
pub use self::uart as uart1;
#[doc = "Universal Asynchronous Receiver/Transmitter 2 (UART2) Registers"]
pub struct Uart2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart2 {}
impl Uart2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xff1a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart2 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter 2 (UART2) Registers"]
pub use self::uart as uart2;
#[doc = "Universal Asynchronous Receiver/Transmitter 3 (UART3) Registers"]
pub struct Uart3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart3 {}
impl Uart3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xff1b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart3 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter 3 (UART3) Registers"]
pub use self::uart as uart3;
#[doc = "Universal Asynchronous Receiver/Transmitter 4 (UART4) Registers"]
pub struct Uart4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart4 {}
impl Uart4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xff37_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart4 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart4").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter 4 (UART4) Registers"]
pub use self::uart as uart4;
#[doc = "USB 3.0/2.0 OTG (USB3) Registers"]
pub struct Usb3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb3 {}
impl Usb3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb3::RegisterBlock = 0xfe80_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usb3 {
    type Target = usb3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb3").finish()
    }
}
#[doc = "USB 3.0/2.0 OTG (USB3) Registers"]
pub mod usb3;
#[doc = "USB 3.0/2.0 OTG Register 0 (USB3_OTG0) Registers"]
pub struct Usb3Otg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb3Otg0 {}
impl Usb3Otg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb3::RegisterBlock = 0xfe80_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usb3Otg0 {
    type Target = usb3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb3Otg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb3Otg0").finish()
    }
}
#[doc = "USB 3.0/2.0 OTG Register 0 (USB3_OTG0) Registers"]
pub use self::usb3 as usb3_otg0;
#[doc = "USB 3.0/2.0 OTG Register 1 (USB3_OTG1) Registers"]
pub struct Usb3Otg1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb3Otg1 {}
impl Usb3Otg1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb3::RegisterBlock = 0xfe90_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usb3Otg1 {
    type Target = usb3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb3Otg1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb3Otg1").finish()
    }
}
#[doc = "USB 3.0/2.0 OTG Register 1 (USB3_OTG1) Registers"]
pub use self::usb3 as usb3_otg1;
#[doc = "Video Processor Unit (VPU) Decoder Registers"]
pub struct Vdpu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vdpu {}
impl Vdpu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vdpu::RegisterBlock = 0xff65_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vdpu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vdpu {
    type Target = vdpu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vdpu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vdpu").finish()
    }
}
#[doc = "Video Processor Unit (VPU) Decoder Registers"]
pub mod vdpu;
#[doc = "Video Processor Unit (VPU) Encoder Registers"]
pub struct Vepu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vepu {}
impl Vepu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vepu::RegisterBlock = 0xff65_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vepu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vepu {
    type Target = vepu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vepu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vepu").finish()
    }
}
#[doc = "Video Processor Unit (VPU) Encoder Registers"]
pub mod vepu;
#[doc = "Visual Output Processor (Big) (VOPB) Registers"]
pub struct Vopb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vopb {}
impl Vopb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vopb::RegisterBlock = 0xff90_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vopb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vopb {
    type Target = vopb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vopb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vopb").finish()
    }
}
#[doc = "Visual Output Processor (Big) (VOPB) Registers"]
pub mod vopb;
#[doc = "Visual Output Processor (Little) (VOPL) Registers"]
pub struct Vopl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vopl {}
impl Vopl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vopl::RegisterBlock = 0xff8f_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vopl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vopl {
    type Target = vopl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vopl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vopl").finish()
    }
}
#[doc = "Visual Output Processor (Little) (VOPL) Registers"]
pub mod vopl;
#[doc = "Watchdog Timer (WDT) Registers"]
pub struct Wdt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt {}
impl Wdt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0xff84_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt").finish()
    }
}
#[doc = "Watchdog Timer (WDT) Registers"]
pub mod wdt;
#[doc = "Watchdog Timer (WDT) 0 Registers"]
pub struct Wdt0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt0 {}
impl Wdt0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0xff84_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt0 {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt0").finish()
    }
}
#[doc = "Watchdog Timer (WDT) 0 Registers"]
pub use self::wdt as wdt0;
#[doc = "Watchdog Timer (WDT) 1 Registers"]
pub struct Wdt1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt1 {}
impl Wdt1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0xff84_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt1 {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt1").finish()
    }
}
#[doc = "Watchdog Timer (WDT) 1 Registers"]
pub use self::wdt as wdt1;
#[doc = "Watchdog Timer (WDT) 2 Registers"]
pub struct Wdt2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt2 {}
impl Wdt2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0xff38_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt2 {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt2").finish()
    }
}
#[doc = "Watchdog Timer (WDT) 2 Registers"]
pub use self::wdt as wdt2;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "CCI500"]
    pub cci500: Cci500,
    #[doc = "CRU"]
    pub cru: Cru,
    #[doc = "CRYPTO"]
    pub crypto: Crypto,
    #[doc = "CRYPTO0"]
    pub crypto0: Crypto0,
    #[doc = "CRYPTO1"]
    pub crypto1: Crypto1,
    #[doc = "DCF"]
    pub dcf: Dcf,
    #[doc = "DDRC"]
    pub ddrc: Ddrc,
    #[doc = "DDRC0"]
    pub ddrc0: Ddrc0,
    #[doc = "DDRC1"]
    pub ddrc1: Ddrc1,
    #[doc = "DDR_CIC"]
    pub ddr_cic: DdrCic,
    #[doc = "DDR_MON"]
    pub ddr_mon: DdrMon,
    #[doc = "DMAC"]
    pub dmac: Dmac,
    #[doc = "DMAC0"]
    pub dmac0: Dmac0,
    #[doc = "DMAC1"]
    pub dmac1: Dmac1,
    #[doc = "DP"]
    pub dp: Dp,
    #[doc = "EFUSE"]
    pub efuse: Efuse,
    #[doc = "EFUSE0"]
    pub efuse0: Efuse0,
    #[doc = "EFUSE1"]
    pub efuse1: Efuse1,
    #[doc = "EMMCCORE"]
    pub emmccore: Emmccore,
    #[doc = "ERR_LOGGER_MSCH"]
    pub err_logger_msch: ErrLoggerMsch,
    #[doc = "ERR_LOGGER_MSCH0"]
    pub err_logger_msch0: ErrLoggerMsch0,
    #[doc = "ERR_LOGGER_MSCH1"]
    pub err_logger_msch1: ErrLoggerMsch1,
    #[doc = "ERR_LOGGER_SLV"]
    pub err_logger_slv: ErrLoggerSlv,
    #[doc = "ERR_LOGGER_SLV0"]
    pub err_logger_slv0: ErrLoggerSlv0,
    #[doc = "ERR_LOGGER_SLV1"]
    pub err_logger_slv1: ErrLoggerSlv1,
    #[doc = "GMAC"]
    pub gmac: Gmac,
    #[doc = "GPIO"]
    pub gpio: Gpio,
    #[doc = "GPIO0"]
    pub gpio0: Gpio0,
    #[doc = "GPIO1"]
    pub gpio1: Gpio1,
    #[doc = "GPIO2"]
    pub gpio2: Gpio2,
    #[doc = "GPIO3"]
    pub gpio3: Gpio3,
    #[doc = "GPIO4"]
    pub gpio4: Gpio4,
    #[doc = "GRF"]
    pub grf: Grf,
    #[doc = "HDMI"]
    pub hdmi: Hdmi,
    #[doc = "I2S"]
    pub i2s: I2s,
    #[doc = "I2S0"]
    pub i2s0: I2s0,
    #[doc = "I2S1"]
    pub i2s1: I2s1,
    #[doc = "I2S2"]
    pub i2s2: I2s2,
    #[doc = "IEP"]
    pub iep: Iep,
    #[doc = "ISP"]
    pub isp: Isp,
    #[doc = "ISP0"]
    pub isp0: Isp0,
    #[doc = "ISP1"]
    pub isp1: Isp1,
    #[doc = "MAILBOX"]
    pub mailbox: Mailbox,
    #[doc = "MAILBOX0"]
    pub mailbox0: Mailbox0,
    #[doc = "MAILBOX1"]
    pub mailbox1: Mailbox1,
    #[doc = "MIPI_DSI_HOST"]
    pub mipi_dsi_host: MipiDsiHost,
    #[doc = "MIPI_DSI_HOST0"]
    pub mipi_dsi_host0: MipiDsiHost0,
    #[doc = "MIPI_DSI_HOST1"]
    pub mipi_dsi_host1: MipiDsiHost1,
    #[doc = "MMU"]
    pub mmu: Mmu,
    #[doc = "MMU0_ISP0"]
    pub mmu0_isp0: Mmu0Isp0,
    #[doc = "MMU0_ISP1"]
    pub mmu0_isp1: Mmu0Isp1,
    #[doc = "MMU1_ISP0"]
    pub mmu1_isp0: Mmu1Isp0,
    #[doc = "MMU1_ISP1"]
    pub mmu1_isp1: Mmu1Isp1,
    #[doc = "MMU_HDCP"]
    pub mmu_hdcp: MmuHdcp,
    #[doc = "MMU_IEP"]
    pub mmu_iep: MmuIep,
    #[doc = "MMU_RKVDEC_R"]
    pub mmu_rkvdec_r: MmuRkvdecR,
    #[doc = "MMU_RKVDEC_W"]
    pub mmu_rkvdec_w: MmuRkvdecW,
    #[doc = "MMU_VOPB"]
    pub mmu_vopb: MmuVopb,
    #[doc = "MMU_VOPL"]
    pub mmu_vopl: MmuVopl,
    #[doc = "MMU_VPU"]
    pub mmu_vpu: MmuVpu,
    #[doc = "MSCH"]
    pub msch: Msch,
    #[doc = "MSCH0"]
    pub msch0: Msch0,
    #[doc = "MSCH1"]
    pub msch1: Msch1,
    #[doc = "PCIE_CLIENT"]
    pub pcie_client: PcieClient,
    #[doc = "PCIE_CORE"]
    pub pcie_core: PcieCore,
    #[doc = "PMU"]
    pub pmu: Pmu,
    #[doc = "PMUCRU"]
    pub pmucru: Pmucru,
    #[doc = "PMUGRF"]
    pub pmugrf: Pmugrf,
    #[doc = "PREF_CACHE"]
    pub pref_cache: PrefCache,
    #[doc = "PREF_CACHE_RKVDEC_CHROMA"]
    pub pref_cache_rkvdec_chroma: PrefCacheRkvdecChroma,
    #[doc = "PREF_CACHE_RKVDEC_LUMA"]
    pub pref_cache_rkvdec_luma: PrefCacheRkvdecLuma,
    #[doc = "PREF_CACHE_VPU"]
    pub pref_cache_vpu: PrefCacheVpu,
    #[doc = "PROBE"]
    pub probe: Probe,
    #[doc = "PROBE_CCI_MSCH0"]
    pub probe_cci_msch0: ProbeCciMsch0,
    #[doc = "PROBE_CCI_MSCH1"]
    pub probe_cci_msch1: ProbeCciMsch1,
    #[doc = "PROBE_GPU_MSCH0"]
    pub probe_gpu_msch0: ProbeGpuMsch0,
    #[doc = "PROBE_GPU_MSCH1"]
    pub probe_gpu_msch1: ProbeGpuMsch1,
    #[doc = "PROBE_PERIHP_MSCH0"]
    pub probe_perihp_msch0: ProbePerihpMsch0,
    #[doc = "PROBE_PERIHP_MSCH1"]
    pub probe_perihp_msch1: ProbePerihpMsch1,
    #[doc = "PROBE_PERILP_MSCH0"]
    pub probe_perilp_msch0: ProbePerilpMsch0,
    #[doc = "PROBE_PERILP_MSCH1"]
    pub probe_perilp_msch1: ProbePerilpMsch1,
    #[doc = "PROBE_VIDEO_MSCH0"]
    pub probe_video_msch0: ProbeVideoMsch0,
    #[doc = "PROBE_VIDEO_MSCH1"]
    pub probe_video_msch1: ProbeVideoMsch1,
    #[doc = "PROBE_VIO0_MSCH0"]
    pub probe_vio0_msch0: ProbeVio0Msch0,
    #[doc = "PROBE_VIO0_MSCH1"]
    pub probe_vio0_msch1: ProbeVio0Msch1,
    #[doc = "PROBE_VIO1_MSCH0"]
    pub probe_vio1_msch0: ProbeVio1Msch0,
    #[doc = "PROBE_VIO1_MSCH1"]
    pub probe_vio1_msch1: ProbeVio1Msch1,
    #[doc = "PWM"]
    pub pwm: Pwm,
    #[doc = "QOS"]
    pub qos: Qos,
    #[doc = "QOS_CCI_M0"]
    pub qos_cci_m0: QosCciM0,
    #[doc = "QOS_CCI_M1"]
    pub qos_cci_m1: QosCciM1,
    #[doc = "QOS_CRYPTO0"]
    pub qos_crypto0: QosCrypto0,
    #[doc = "QOS_CRYPTO1"]
    pub qos_crypto1: QosCrypto1,
    #[doc = "QOS_DCF"]
    pub qos_dcf: QosDcf,
    #[doc = "QOS_DMAC0"]
    pub qos_dmac0: QosDmac0,
    #[doc = "QOS_DMAC1"]
    pub qos_dmac1: QosDmac1,
    #[doc = "QOS_EMMC"]
    pub qos_emmc: QosEmmc,
    #[doc = "QOS_GIC"]
    pub qos_gic: QosGic,
    #[doc = "QOS_GMAC"]
    pub qos_gmac: QosGmac,
    #[doc = "QOS_GPU"]
    pub qos_gpu: QosGpu,
    #[doc = "QOS_HDCP"]
    pub qos_hdcp: QosHdcp,
    #[doc = "QOS_HSIC"]
    pub qos_hsic: QosHsic,
    #[doc = "QOS_IEP"]
    pub qos_iep: QosIep,
    #[doc = "QOS_ISP0_M0"]
    pub qos_isp0_m0: QosIsp0M0,
    #[doc = "QOS_ISP0_M1"]
    pub qos_isp0_m1: QosIsp0M1,
    #[doc = "QOS_ISP1_M0"]
    pub qos_isp1_m0: QosIsp1M0,
    #[doc = "QOS_ISP1_M1"]
    pub qos_isp1_m1: QosIsp1M1,
    #[doc = "QOS_PCIE"]
    pub qos_pcie: QosPcie,
    #[doc = "QOS_PERIHP_NSP"]
    pub qos_perihp_nsp: QosPerihpNsp,
    #[doc = "QOS_PERILPSLV_NSP"]
    pub qos_perilpslv_nsp: QosPerilpslvNsp,
    #[doc = "QOS_PERILP_NSP"]
    pub qos_perilp_nsp: QosPerilpNsp,
    #[doc = "QOS_PERI_CM0"]
    pub qos_peri_cm0: QosPeriCm0,
    #[doc = "QOS_PMU_CM0"]
    pub qos_pmu_cm0: QosPmuCm0,
    #[doc = "QOS_RGA_R"]
    pub qos_rga_r: QosRgaR,
    #[doc = "QOS_RGA_W"]
    pub qos_rga_w: QosRgaW,
    #[doc = "QOS_SDIO"]
    pub qos_sdio: QosSdio,
    #[doc = "QOS_SDMMC"]
    pub qos_sdmmc: QosSdmmc,
    #[doc = "QOS_USB_HOST0"]
    pub qos_usb_host0: QosUsbHost0,
    #[doc = "QOS_USB_HOST1"]
    pub qos_usb_host1: QosUsbHost1,
    #[doc = "QOS_USB_OTG0"]
    pub qos_usb_otg0: QosUsbOtg0,
    #[doc = "QOS_USB_OTG1"]
    pub qos_usb_otg1: QosUsbOtg1,
    #[doc = "QOS_VIDEO_M0"]
    pub qos_video_m0: QosVideoM0,
    #[doc = "QOS_VIDEO_M1_R"]
    pub qos_video_m1_r: QosVideoM1R,
    #[doc = "QOS_VIDEO_M1_W"]
    pub qos_video_m1_w: QosVideoM1W,
    #[doc = "QOS_VOP_BIG_R"]
    pub qos_vop_big_r: QosVopBigR,
    #[doc = "QOS_VOP_BIG_W"]
    pub qos_vop_big_w: QosVopBigW,
    #[doc = "QOS_VOP_LITTLE"]
    pub qos_vop_little: QosVopLittle,
    #[doc = "RGA2"]
    pub rga2: Rga2,
    #[doc = "RKI2C"]
    pub rki2c: Rki2c,
    #[doc = "RKI2C0"]
    pub rki2c0: Rki2c0,
    #[doc = "RKI2C1"]
    pub rki2c1: Rki2c1,
    #[doc = "RKI2C2"]
    pub rki2c2: Rki2c2,
    #[doc = "RKI2C3"]
    pub rki2c3: Rki2c3,
    #[doc = "RKI2C4"]
    pub rki2c4: Rki2c4,
    #[doc = "RKI2C5"]
    pub rki2c5: Rki2c5,
    #[doc = "RKI2C6"]
    pub rki2c6: Rki2c6,
    #[doc = "RKI2C7"]
    pub rki2c7: Rki2c7,
    #[doc = "RKI2C8"]
    pub rki2c8: Rki2c8,
    #[doc = "RKVDEC"]
    pub rkvdec: Rkvdec,
    #[doc = "SARADC"]
    pub saradc: Saradc,
    #[doc = "SDMMC"]
    pub sdmmc: Sdmmc,
    #[doc = "SPDIF"]
    pub spdif: Spdif,
    #[doc = "SPI"]
    pub spi: Spi,
    #[doc = "SPI0"]
    pub spi0: Spi0,
    #[doc = "SPI1"]
    pub spi1: Spi1,
    #[doc = "SPI2"]
    pub spi2: Spi2,
    #[doc = "SPI3"]
    pub spi3: Spi3,
    #[doc = "SPI4"]
    pub spi4: Spi4,
    #[doc = "SPI5"]
    pub spi5: Spi5,
    #[doc = "TIMER"]
    pub timer: Timer,
    #[doc = "TIMER0"]
    pub timer0: Timer0,
    #[doc = "TIMER1"]
    pub timer1: Timer1,
    #[doc = "TIMER10"]
    pub timer10: Timer10,
    #[doc = "TIMER11"]
    pub timer11: Timer11,
    #[doc = "TIMER2"]
    pub timer2: Timer2,
    #[doc = "TIMER3"]
    pub timer3: Timer3,
    #[doc = "TIMER4"]
    pub timer4: Timer4,
    #[doc = "TIMER5"]
    pub timer5: Timer5,
    #[doc = "TIMER6"]
    pub timer6: Timer6,
    #[doc = "TIMER7"]
    pub timer7: Timer7,
    #[doc = "TIMER8"]
    pub timer8: Timer8,
    #[doc = "TIMER9"]
    pub timer9: Timer9,
    #[doc = "PMUTIMER0"]
    pub pmutimer0: Pmutimer0,
    #[doc = "PMUTIMER1"]
    pub pmutimer1: Pmutimer1,
    #[doc = "STIMER0"]
    pub stimer0: Stimer0,
    #[doc = "STIMER1"]
    pub stimer1: Stimer1,
    #[doc = "STIMER10"]
    pub stimer10: Stimer10,
    #[doc = "STIMER11"]
    pub stimer11: Stimer11,
    #[doc = "STIMER2"]
    pub stimer2: Stimer2,
    #[doc = "STIMER3"]
    pub stimer3: Stimer3,
    #[doc = "STIMER4"]
    pub stimer4: Stimer4,
    #[doc = "STIMER5"]
    pub stimer5: Stimer5,
    #[doc = "STIMER6"]
    pub stimer6: Stimer6,
    #[doc = "STIMER7"]
    pub stimer7: Stimer7,
    #[doc = "STIMER8"]
    pub stimer8: Stimer8,
    #[doc = "STIMER9"]
    pub stimer9: Stimer9,
    #[doc = "TSADC"]
    pub tsadc: Tsadc,
    #[doc = "TYPEC_PD"]
    pub typec_pd: TypecPd,
    #[doc = "TYPEC_PD0"]
    pub typec_pd0: TypecPd0,
    #[doc = "TYPEC_PD1"]
    pub typec_pd1: TypecPd1,
    #[doc = "TYPEC_PHY"]
    pub typec_phy: TypecPhy,
    #[doc = "TYPEC_PHY0"]
    pub typec_phy0: TypecPhy0,
    #[doc = "TYPEC_PHY1"]
    pub typec_phy1: TypecPhy1,
    #[doc = "UART"]
    pub uart: Uart,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "UART4"]
    pub uart4: Uart4,
    #[doc = "USB3"]
    pub usb3: Usb3,
    #[doc = "USB3_OTG0"]
    pub usb3_otg0: Usb3Otg0,
    #[doc = "USB3_OTG1"]
    pub usb3_otg1: Usb3Otg1,
    #[doc = "VDPU"]
    pub vdpu: Vdpu,
    #[doc = "VEPU"]
    pub vepu: Vepu,
    #[doc = "VOPB"]
    pub vopb: Vopb,
    #[doc = "VOPL"]
    pub vopl: Vopl,
    #[doc = "WDT"]
    pub wdt: Wdt,
    #[doc = "WDT0"]
    pub wdt0: Wdt0,
    #[doc = "WDT1"]
    pub wdt1: Wdt1,
    #[doc = "WDT2"]
    pub wdt2: Wdt2,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            cci500: Cci500 {
                _marker: PhantomData,
            },
            cru: Cru {
                _marker: PhantomData,
            },
            crypto: Crypto {
                _marker: PhantomData,
            },
            crypto0: Crypto0 {
                _marker: PhantomData,
            },
            crypto1: Crypto1 {
                _marker: PhantomData,
            },
            dcf: Dcf {
                _marker: PhantomData,
            },
            ddrc: Ddrc {
                _marker: PhantomData,
            },
            ddrc0: Ddrc0 {
                _marker: PhantomData,
            },
            ddrc1: Ddrc1 {
                _marker: PhantomData,
            },
            ddr_cic: DdrCic {
                _marker: PhantomData,
            },
            ddr_mon: DdrMon {
                _marker: PhantomData,
            },
            dmac: Dmac {
                _marker: PhantomData,
            },
            dmac0: Dmac0 {
                _marker: PhantomData,
            },
            dmac1: Dmac1 {
                _marker: PhantomData,
            },
            dp: Dp {
                _marker: PhantomData,
            },
            efuse: Efuse {
                _marker: PhantomData,
            },
            efuse0: Efuse0 {
                _marker: PhantomData,
            },
            efuse1: Efuse1 {
                _marker: PhantomData,
            },
            emmccore: Emmccore {
                _marker: PhantomData,
            },
            err_logger_msch: ErrLoggerMsch {
                _marker: PhantomData,
            },
            err_logger_msch0: ErrLoggerMsch0 {
                _marker: PhantomData,
            },
            err_logger_msch1: ErrLoggerMsch1 {
                _marker: PhantomData,
            },
            err_logger_slv: ErrLoggerSlv {
                _marker: PhantomData,
            },
            err_logger_slv0: ErrLoggerSlv0 {
                _marker: PhantomData,
            },
            err_logger_slv1: ErrLoggerSlv1 {
                _marker: PhantomData,
            },
            gmac: Gmac {
                _marker: PhantomData,
            },
            gpio: Gpio {
                _marker: PhantomData,
            },
            gpio0: Gpio0 {
                _marker: PhantomData,
            },
            gpio1: Gpio1 {
                _marker: PhantomData,
            },
            gpio2: Gpio2 {
                _marker: PhantomData,
            },
            gpio3: Gpio3 {
                _marker: PhantomData,
            },
            gpio4: Gpio4 {
                _marker: PhantomData,
            },
            grf: Grf {
                _marker: PhantomData,
            },
            hdmi: Hdmi {
                _marker: PhantomData,
            },
            i2s: I2s {
                _marker: PhantomData,
            },
            i2s0: I2s0 {
                _marker: PhantomData,
            },
            i2s1: I2s1 {
                _marker: PhantomData,
            },
            i2s2: I2s2 {
                _marker: PhantomData,
            },
            iep: Iep {
                _marker: PhantomData,
            },
            isp: Isp {
                _marker: PhantomData,
            },
            isp0: Isp0 {
                _marker: PhantomData,
            },
            isp1: Isp1 {
                _marker: PhantomData,
            },
            mailbox: Mailbox {
                _marker: PhantomData,
            },
            mailbox0: Mailbox0 {
                _marker: PhantomData,
            },
            mailbox1: Mailbox1 {
                _marker: PhantomData,
            },
            mipi_dsi_host: MipiDsiHost {
                _marker: PhantomData,
            },
            mipi_dsi_host0: MipiDsiHost0 {
                _marker: PhantomData,
            },
            mipi_dsi_host1: MipiDsiHost1 {
                _marker: PhantomData,
            },
            mmu: Mmu {
                _marker: PhantomData,
            },
            mmu0_isp0: Mmu0Isp0 {
                _marker: PhantomData,
            },
            mmu0_isp1: Mmu0Isp1 {
                _marker: PhantomData,
            },
            mmu1_isp0: Mmu1Isp0 {
                _marker: PhantomData,
            },
            mmu1_isp1: Mmu1Isp1 {
                _marker: PhantomData,
            },
            mmu_hdcp: MmuHdcp {
                _marker: PhantomData,
            },
            mmu_iep: MmuIep {
                _marker: PhantomData,
            },
            mmu_rkvdec_r: MmuRkvdecR {
                _marker: PhantomData,
            },
            mmu_rkvdec_w: MmuRkvdecW {
                _marker: PhantomData,
            },
            mmu_vopb: MmuVopb {
                _marker: PhantomData,
            },
            mmu_vopl: MmuVopl {
                _marker: PhantomData,
            },
            mmu_vpu: MmuVpu {
                _marker: PhantomData,
            },
            msch: Msch {
                _marker: PhantomData,
            },
            msch0: Msch0 {
                _marker: PhantomData,
            },
            msch1: Msch1 {
                _marker: PhantomData,
            },
            pcie_client: PcieClient {
                _marker: PhantomData,
            },
            pcie_core: PcieCore {
                _marker: PhantomData,
            },
            pmu: Pmu {
                _marker: PhantomData,
            },
            pmucru: Pmucru {
                _marker: PhantomData,
            },
            pmugrf: Pmugrf {
                _marker: PhantomData,
            },
            pref_cache: PrefCache {
                _marker: PhantomData,
            },
            pref_cache_rkvdec_chroma: PrefCacheRkvdecChroma {
                _marker: PhantomData,
            },
            pref_cache_rkvdec_luma: PrefCacheRkvdecLuma {
                _marker: PhantomData,
            },
            pref_cache_vpu: PrefCacheVpu {
                _marker: PhantomData,
            },
            probe: Probe {
                _marker: PhantomData,
            },
            probe_cci_msch0: ProbeCciMsch0 {
                _marker: PhantomData,
            },
            probe_cci_msch1: ProbeCciMsch1 {
                _marker: PhantomData,
            },
            probe_gpu_msch0: ProbeGpuMsch0 {
                _marker: PhantomData,
            },
            probe_gpu_msch1: ProbeGpuMsch1 {
                _marker: PhantomData,
            },
            probe_perihp_msch0: ProbePerihpMsch0 {
                _marker: PhantomData,
            },
            probe_perihp_msch1: ProbePerihpMsch1 {
                _marker: PhantomData,
            },
            probe_perilp_msch0: ProbePerilpMsch0 {
                _marker: PhantomData,
            },
            probe_perilp_msch1: ProbePerilpMsch1 {
                _marker: PhantomData,
            },
            probe_video_msch0: ProbeVideoMsch0 {
                _marker: PhantomData,
            },
            probe_video_msch1: ProbeVideoMsch1 {
                _marker: PhantomData,
            },
            probe_vio0_msch0: ProbeVio0Msch0 {
                _marker: PhantomData,
            },
            probe_vio0_msch1: ProbeVio0Msch1 {
                _marker: PhantomData,
            },
            probe_vio1_msch0: ProbeVio1Msch0 {
                _marker: PhantomData,
            },
            probe_vio1_msch1: ProbeVio1Msch1 {
                _marker: PhantomData,
            },
            pwm: Pwm {
                _marker: PhantomData,
            },
            qos: Qos {
                _marker: PhantomData,
            },
            qos_cci_m0: QosCciM0 {
                _marker: PhantomData,
            },
            qos_cci_m1: QosCciM1 {
                _marker: PhantomData,
            },
            qos_crypto0: QosCrypto0 {
                _marker: PhantomData,
            },
            qos_crypto1: QosCrypto1 {
                _marker: PhantomData,
            },
            qos_dcf: QosDcf {
                _marker: PhantomData,
            },
            qos_dmac0: QosDmac0 {
                _marker: PhantomData,
            },
            qos_dmac1: QosDmac1 {
                _marker: PhantomData,
            },
            qos_emmc: QosEmmc {
                _marker: PhantomData,
            },
            qos_gic: QosGic {
                _marker: PhantomData,
            },
            qos_gmac: QosGmac {
                _marker: PhantomData,
            },
            qos_gpu: QosGpu {
                _marker: PhantomData,
            },
            qos_hdcp: QosHdcp {
                _marker: PhantomData,
            },
            qos_hsic: QosHsic {
                _marker: PhantomData,
            },
            qos_iep: QosIep {
                _marker: PhantomData,
            },
            qos_isp0_m0: QosIsp0M0 {
                _marker: PhantomData,
            },
            qos_isp0_m1: QosIsp0M1 {
                _marker: PhantomData,
            },
            qos_isp1_m0: QosIsp1M0 {
                _marker: PhantomData,
            },
            qos_isp1_m1: QosIsp1M1 {
                _marker: PhantomData,
            },
            qos_pcie: QosPcie {
                _marker: PhantomData,
            },
            qos_perihp_nsp: QosPerihpNsp {
                _marker: PhantomData,
            },
            qos_perilpslv_nsp: QosPerilpslvNsp {
                _marker: PhantomData,
            },
            qos_perilp_nsp: QosPerilpNsp {
                _marker: PhantomData,
            },
            qos_peri_cm0: QosPeriCm0 {
                _marker: PhantomData,
            },
            qos_pmu_cm0: QosPmuCm0 {
                _marker: PhantomData,
            },
            qos_rga_r: QosRgaR {
                _marker: PhantomData,
            },
            qos_rga_w: QosRgaW {
                _marker: PhantomData,
            },
            qos_sdio: QosSdio {
                _marker: PhantomData,
            },
            qos_sdmmc: QosSdmmc {
                _marker: PhantomData,
            },
            qos_usb_host0: QosUsbHost0 {
                _marker: PhantomData,
            },
            qos_usb_host1: QosUsbHost1 {
                _marker: PhantomData,
            },
            qos_usb_otg0: QosUsbOtg0 {
                _marker: PhantomData,
            },
            qos_usb_otg1: QosUsbOtg1 {
                _marker: PhantomData,
            },
            qos_video_m0: QosVideoM0 {
                _marker: PhantomData,
            },
            qos_video_m1_r: QosVideoM1R {
                _marker: PhantomData,
            },
            qos_video_m1_w: QosVideoM1W {
                _marker: PhantomData,
            },
            qos_vop_big_r: QosVopBigR {
                _marker: PhantomData,
            },
            qos_vop_big_w: QosVopBigW {
                _marker: PhantomData,
            },
            qos_vop_little: QosVopLittle {
                _marker: PhantomData,
            },
            rga2: Rga2 {
                _marker: PhantomData,
            },
            rki2c: Rki2c {
                _marker: PhantomData,
            },
            rki2c0: Rki2c0 {
                _marker: PhantomData,
            },
            rki2c1: Rki2c1 {
                _marker: PhantomData,
            },
            rki2c2: Rki2c2 {
                _marker: PhantomData,
            },
            rki2c3: Rki2c3 {
                _marker: PhantomData,
            },
            rki2c4: Rki2c4 {
                _marker: PhantomData,
            },
            rki2c5: Rki2c5 {
                _marker: PhantomData,
            },
            rki2c6: Rki2c6 {
                _marker: PhantomData,
            },
            rki2c7: Rki2c7 {
                _marker: PhantomData,
            },
            rki2c8: Rki2c8 {
                _marker: PhantomData,
            },
            rkvdec: Rkvdec {
                _marker: PhantomData,
            },
            saradc: Saradc {
                _marker: PhantomData,
            },
            sdmmc: Sdmmc {
                _marker: PhantomData,
            },
            spdif: Spdif {
                _marker: PhantomData,
            },
            spi: Spi {
                _marker: PhantomData,
            },
            spi0: Spi0 {
                _marker: PhantomData,
            },
            spi1: Spi1 {
                _marker: PhantomData,
            },
            spi2: Spi2 {
                _marker: PhantomData,
            },
            spi3: Spi3 {
                _marker: PhantomData,
            },
            spi4: Spi4 {
                _marker: PhantomData,
            },
            spi5: Spi5 {
                _marker: PhantomData,
            },
            timer: Timer {
                _marker: PhantomData,
            },
            timer0: Timer0 {
                _marker: PhantomData,
            },
            timer1: Timer1 {
                _marker: PhantomData,
            },
            timer10: Timer10 {
                _marker: PhantomData,
            },
            timer11: Timer11 {
                _marker: PhantomData,
            },
            timer2: Timer2 {
                _marker: PhantomData,
            },
            timer3: Timer3 {
                _marker: PhantomData,
            },
            timer4: Timer4 {
                _marker: PhantomData,
            },
            timer5: Timer5 {
                _marker: PhantomData,
            },
            timer6: Timer6 {
                _marker: PhantomData,
            },
            timer7: Timer7 {
                _marker: PhantomData,
            },
            timer8: Timer8 {
                _marker: PhantomData,
            },
            timer9: Timer9 {
                _marker: PhantomData,
            },
            pmutimer0: Pmutimer0 {
                _marker: PhantomData,
            },
            pmutimer1: Pmutimer1 {
                _marker: PhantomData,
            },
            stimer0: Stimer0 {
                _marker: PhantomData,
            },
            stimer1: Stimer1 {
                _marker: PhantomData,
            },
            stimer10: Stimer10 {
                _marker: PhantomData,
            },
            stimer11: Stimer11 {
                _marker: PhantomData,
            },
            stimer2: Stimer2 {
                _marker: PhantomData,
            },
            stimer3: Stimer3 {
                _marker: PhantomData,
            },
            stimer4: Stimer4 {
                _marker: PhantomData,
            },
            stimer5: Stimer5 {
                _marker: PhantomData,
            },
            stimer6: Stimer6 {
                _marker: PhantomData,
            },
            stimer7: Stimer7 {
                _marker: PhantomData,
            },
            stimer8: Stimer8 {
                _marker: PhantomData,
            },
            stimer9: Stimer9 {
                _marker: PhantomData,
            },
            tsadc: Tsadc {
                _marker: PhantomData,
            },
            typec_pd: TypecPd {
                _marker: PhantomData,
            },
            typec_pd0: TypecPd0 {
                _marker: PhantomData,
            },
            typec_pd1: TypecPd1 {
                _marker: PhantomData,
            },
            typec_phy: TypecPhy {
                _marker: PhantomData,
            },
            typec_phy0: TypecPhy0 {
                _marker: PhantomData,
            },
            typec_phy1: TypecPhy1 {
                _marker: PhantomData,
            },
            uart: Uart {
                _marker: PhantomData,
            },
            uart0: Uart0 {
                _marker: PhantomData,
            },
            uart1: Uart1 {
                _marker: PhantomData,
            },
            uart2: Uart2 {
                _marker: PhantomData,
            },
            uart3: Uart3 {
                _marker: PhantomData,
            },
            uart4: Uart4 {
                _marker: PhantomData,
            },
            usb3: Usb3 {
                _marker: PhantomData,
            },
            usb3_otg0: Usb3Otg0 {
                _marker: PhantomData,
            },
            usb3_otg1: Usb3Otg1 {
                _marker: PhantomData,
            },
            vdpu: Vdpu {
                _marker: PhantomData,
            },
            vepu: Vepu {
                _marker: PhantomData,
            },
            vopb: Vopb {
                _marker: PhantomData,
            },
            vopl: Vopl {
                _marker: PhantomData,
            },
            wdt: Wdt {
                _marker: PhantomData,
            },
            wdt0: Wdt0 {
                _marker: PhantomData,
            },
            wdt1: Wdt1 {
                _marker: PhantomData,
            },
            wdt2: Wdt2 {
                _marker: PhantomData,
            },
        }
    }
}
