#[doc = "Register `PCI_EXPRESS_DEVICE_CONTROL_AND_STATUS` reader"]
pub type R = crate::R<PciExpressDeviceControlAndStatusSpec>;
#[doc = "Register `PCI_EXPRESS_DEVICE_CONTROL_AND_STATUS` writer"]
pub type W = crate::W<PciExpressDeviceControlAndStatusSpec>;
#[doc = "Field `ECER` reader - Enable Correctable Error Reporting \\[ECER\\]
This bit is not used by the core in Root Port mode."]
pub type EcerR = crate::BitReader;
#[doc = "Field `ECER` writer - Enable Correctable Error Reporting \\[ECER\\]
This bit is not used by the core in Root Port mode."]
pub type EcerW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `ENFER` reader - Enable Non- Fatal Error Reporting \\[ENFER\\]
This bit is not used by the core in Root Port mode."]
pub type EnferR = crate::BitReader;
#[doc = "Field `ENFER` writer - Enable Non- Fatal Error Reporting \\[ENFER\\]
This bit is not used by the core in Root Port mode."]
pub type EnferW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `EFER` reader - Enable Fatal Error Reporting \\[EFER\\]
This bit is not used by the core in Root Port mode."]
pub type EferR = crate::BitReader;
#[doc = "Field `EFER` writer - Enable Fatal Error Reporting \\[EFER\\]
This bit is not used by the core in Root Port mode."]
pub type EferW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `EURR` reader - Enable Unsupported Request Reporting \\[EURR\\]
Enables the sending of error messages by the core on receiving unsupported requests."]
pub type EurrR = crate::BitReader;
#[doc = "Field `EURR` writer - Enable Unsupported Request Reporting \\[EURR\\]
Enables the sending of error messages by the core on receiving unsupported requests."]
pub type EurrW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `ERO` reader - Enable Relaxed Ordering \\[ERO\\]
When set, this bit indicates that the device is allowed to set the Relaxed Ordering bit in the Attributes field of transactions initiated from it. when the transactions do not require Strong Ordering."]
pub type EroR = crate::BitReader;
#[doc = "Field `ERO` writer - Enable Relaxed Ordering \\[ERO\\]
When set, this bit indicates that the device is allowed to set the Relaxed Ordering bit in the Attributes field of transactions initiated from it. when the transactions do not require Strong Ordering."]
pub type EroW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `MP` reader - Max Payload Size \\[MP\\]
Specifies the maximum TLP payload size configured. The device must be able to receive a TLP of this maximum size, and should not generate TLP's larger than this value. Software must set this field based on the maximum payload size in the Device Capabilities Register, and the capability of the other side."]
pub type MpR = crate::FieldReader;
#[doc = "Field `MP` writer - Max Payload Size \\[MP\\]
Specifies the maximum TLP payload size configured. The device must be able to receive a TLP of this maximum size, and should not generate TLP's larger than this value. Software must set this field based on the maximum payload size in the Device Capabilities Register, and the capability of the other side."]
pub type MpW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
#[doc = "Field `ETE` reader - Extended Tag Enable \\[ETE\\]
extended tag not enabled. Hence hard coded to zero ."]
pub type EteR = crate::BitReader;
#[doc = "Field `PFE` reader - phantum functions enable \\[PFE\\]
Hardwired to 0"]
pub type PfeR = crate::BitReader;
#[doc = "Field `APPME` reader - aux power PM enable \\[APPME\\]
Hardwired to 0"]
pub type AppmeR = crate::BitReader;
#[doc = "Field `ENS` reader - Enable no snoop \\[ENS\\]
If this bit is Set, the Function is permitted to Set the No Snoop bit in the Requester Attributes of transactions it initiates that do not require hardware enforced cache coherency."]
pub type EnsR = crate::BitReader;
#[doc = "Field `ENS` writer - Enable no snoop \\[ENS\\]
If this bit is Set, the Function is permitted to Set the No Snoop bit in the Requester Attributes of transactions it initiates that do not require hardware enforced cache coherency."]
pub type EnsW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `MRR` reader - Max Read Request Size \\[MRR\\]
Specifies the maximum size allowed in read requests generated by the device."]
pub type MrrR = crate::FieldReader;
#[doc = "Field `MRR` writer - Max Read Request Size \\[MRR\\]
Specifies the maximum size allowed in read requests generated by the device."]
pub type MrrW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
#[doc = "Field `R7` reader - Reserved \\[R7\\]
Hardwired to 0."]
pub type R7R = crate::BitReader;
#[doc = "Field `CED` reader - Correctable Error Detected \\[CED\\]
Set to 1 by the core when it detects a correctable error, regardless of whether the error is masked."]
pub type CedR = crate::BitReader;
#[doc = "Field `CED` writer - Correctable Error Detected \\[CED\\]
Set to 1 by the core when it detects a correctable error, regardless of whether the error is masked."]
pub type CedW<'a, REG> = crate::BitWriter1C<'a, REG>;
#[doc = "Field `NFED` reader - Non-Fatal Error Detected \\[NFED\\]
Set to 1 by the core when it detects a non-fatal error, regardless of whether the error is masked."]
pub type NfedR = crate::BitReader;
#[doc = "Field `NFED` writer - Non-Fatal Error Detected \\[NFED\\]
Set to 1 by the core when it detects a non-fatal error, regardless of whether the error is masked."]
pub type NfedW<'a, REG> = crate::BitWriter1C<'a, REG>;
#[doc = "Field `FED` reader - Fatal Error Detected \\[FED\\]
Set to 1 by the core when it detects a fatal error, regardless of whether the error is masked."]
pub type FedR = crate::BitReader;
#[doc = "Field `FED` writer - Fatal Error Detected \\[FED\\]
Set to 1 by the core when it detects a fatal error, regardless of whether the error is masked."]
pub type FedW<'a, REG> = crate::BitWriter1C<'a, REG>;
#[doc = "Field `URD` reader - Unsupported Request Detected \\[URD\\]
Set to 1 by the core when it receives an unsupported request."]
pub type UrdR = crate::BitReader;
#[doc = "Field `URD` writer - Unsupported Request Detected \\[URD\\]
Set to 1 by the core when it receives an unsupported request."]
pub type UrdW<'a, REG> = crate::BitWriter1C<'a, REG>;
#[doc = "Field `APD` reader - Aux Power Detected \\[APD\\]
Set when auxiliary power is detected by the device. This is an unused field."]
pub type ApdR = crate::BitReader;
#[doc = "Field `TP` reader - Transaction Pending \\[TP\\]
Indicates if any of the Non-Posted requests issued by the RC are still pending."]
pub type TpR = crate::BitReader;
#[doc = "Field `R8` reader - Reserved \\[R8\\]
(no description)"]
pub type R8R = crate::FieldReader<u16>;
impl R {
    #[doc = "Bit 0 - Enable Correctable Error Reporting \\[ECER\\]
This bit is not used by the core in Root Port mode."]
    #[inline(always)]
    pub fn ecer(&self) -> EcerR {
        EcerR::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - Enable Non- Fatal Error Reporting \\[ENFER\\]
This bit is not used by the core in Root Port mode."]
    #[inline(always)]
    pub fn enfer(&self) -> EnferR {
        EnferR::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bit 2 - Enable Fatal Error Reporting \\[EFER\\]
This bit is not used by the core in Root Port mode."]
    #[inline(always)]
    pub fn efer(&self) -> EferR {
        EferR::new(((self.bits >> 2) & 1) != 0)
    }
    #[doc = "Bit 3 - Enable Unsupported Request Reporting \\[EURR\\]
Enables the sending of error messages by the core on receiving unsupported requests."]
    #[inline(always)]
    pub fn eurr(&self) -> EurrR {
        EurrR::new(((self.bits >> 3) & 1) != 0)
    }
    #[doc = "Bit 4 - Enable Relaxed Ordering \\[ERO\\]
When set, this bit indicates that the device is allowed to set the Relaxed Ordering bit in the Attributes field of transactions initiated from it. when the transactions do not require Strong Ordering."]
    #[inline(always)]
    pub fn ero(&self) -> EroR {
        EroR::new(((self.bits >> 4) & 1) != 0)
    }
    #[doc = "Bits 5:7 - Max Payload Size \\[MP\\]
Specifies the maximum TLP payload size configured. The device must be able to receive a TLP of this maximum size, and should not generate TLP's larger than this value. Software must set this field based on the maximum payload size in the Device Capabilities Register, and the capability of the other side."]
    #[inline(always)]
    pub fn mp(&self) -> MpR {
        MpR::new(((self.bits >> 5) & 7) as u8)
    }
    #[doc = "Bit 8 - Extended Tag Enable \\[ETE\\]
extended tag not enabled. Hence hard coded to zero ."]
    #[inline(always)]
    pub fn ete(&self) -> EteR {
        EteR::new(((self.bits >> 8) & 1) != 0)
    }
    #[doc = "Bit 9 - phantum functions enable \\[PFE\\]
Hardwired to 0"]
    #[inline(always)]
    pub fn pfe(&self) -> PfeR {
        PfeR::new(((self.bits >> 9) & 1) != 0)
    }
    #[doc = "Bit 10 - aux power PM enable \\[APPME\\]
Hardwired to 0"]
    #[inline(always)]
    pub fn appme(&self) -> AppmeR {
        AppmeR::new(((self.bits >> 10) & 1) != 0)
    }
    #[doc = "Bit 11 - Enable no snoop \\[ENS\\]
If this bit is Set, the Function is permitted to Set the No Snoop bit in the Requester Attributes of transactions it initiates that do not require hardware enforced cache coherency."]
    #[inline(always)]
    pub fn ens(&self) -> EnsR {
        EnsR::new(((self.bits >> 11) & 1) != 0)
    }
    #[doc = "Bits 12:14 - Max Read Request Size \\[MRR\\]
Specifies the maximum size allowed in read requests generated by the device."]
    #[inline(always)]
    pub fn mrr(&self) -> MrrR {
        MrrR::new(((self.bits >> 12) & 7) as u8)
    }
    #[doc = "Bit 15 - Reserved \\[R7\\]
Hardwired to 0."]
    #[inline(always)]
    pub fn r7(&self) -> R7R {
        R7R::new(((self.bits >> 15) & 1) != 0)
    }
    #[doc = "Bit 16 - Correctable Error Detected \\[CED\\]
Set to 1 by the core when it detects a correctable error, regardless of whether the error is masked."]
    #[inline(always)]
    pub fn ced(&self) -> CedR {
        CedR::new(((self.bits >> 16) & 1) != 0)
    }
    #[doc = "Bit 17 - Non-Fatal Error Detected \\[NFED\\]
Set to 1 by the core when it detects a non-fatal error, regardless of whether the error is masked."]
    #[inline(always)]
    pub fn nfed(&self) -> NfedR {
        NfedR::new(((self.bits >> 17) & 1) != 0)
    }
    #[doc = "Bit 18 - Fatal Error Detected \\[FED\\]
Set to 1 by the core when it detects a fatal error, regardless of whether the error is masked."]
    #[inline(always)]
    pub fn fed(&self) -> FedR {
        FedR::new(((self.bits >> 18) & 1) != 0)
    }
    #[doc = "Bit 19 - Unsupported Request Detected \\[URD\\]
Set to 1 by the core when it receives an unsupported request."]
    #[inline(always)]
    pub fn urd(&self) -> UrdR {
        UrdR::new(((self.bits >> 19) & 1) != 0)
    }
    #[doc = "Bit 20 - Aux Power Detected \\[APD\\]
Set when auxiliary power is detected by the device. This is an unused field."]
    #[inline(always)]
    pub fn apd(&self) -> ApdR {
        ApdR::new(((self.bits >> 20) & 1) != 0)
    }
    #[doc = "Bit 21 - Transaction Pending \\[TP\\]
Indicates if any of the Non-Posted requests issued by the RC are still pending."]
    #[inline(always)]
    pub fn tp(&self) -> TpR {
        TpR::new(((self.bits >> 21) & 1) != 0)
    }
    #[doc = "Bits 22:31 - Reserved \\[R8\\]
(no description)"]
    #[inline(always)]
    pub fn r8(&self) -> R8R {
        R8R::new(((self.bits >> 22) & 0x03ff) as u16)
    }
}
impl W {
    #[doc = "Bit 0 - Enable Correctable Error Reporting \\[ECER\\]
This bit is not used by the core in Root Port mode."]
    #[inline(always)]
    #[must_use]
    pub fn ecer(&mut self) -> EcerW<PciExpressDeviceControlAndStatusSpec> {
        EcerW::new(self, 0)
    }
    #[doc = "Bit 1 - Enable Non- Fatal Error Reporting \\[ENFER\\]
This bit is not used by the core in Root Port mode."]
    #[inline(always)]
    #[must_use]
    pub fn enfer(&mut self) -> EnferW<PciExpressDeviceControlAndStatusSpec> {
        EnferW::new(self, 1)
    }
    #[doc = "Bit 2 - Enable Fatal Error Reporting \\[EFER\\]
This bit is not used by the core in Root Port mode."]
    #[inline(always)]
    #[must_use]
    pub fn efer(&mut self) -> EferW<PciExpressDeviceControlAndStatusSpec> {
        EferW::new(self, 2)
    }
    #[doc = "Bit 3 - Enable Unsupported Request Reporting \\[EURR\\]
Enables the sending of error messages by the core on receiving unsupported requests."]
    #[inline(always)]
    #[must_use]
    pub fn eurr(&mut self) -> EurrW<PciExpressDeviceControlAndStatusSpec> {
        EurrW::new(self, 3)
    }
    #[doc = "Bit 4 - Enable Relaxed Ordering \\[ERO\\]
When set, this bit indicates that the device is allowed to set the Relaxed Ordering bit in the Attributes field of transactions initiated from it. when the transactions do not require Strong Ordering."]
    #[inline(always)]
    #[must_use]
    pub fn ero(&mut self) -> EroW<PciExpressDeviceControlAndStatusSpec> {
        EroW::new(self, 4)
    }
    #[doc = "Bits 5:7 - Max Payload Size \\[MP\\]
Specifies the maximum TLP payload size configured. The device must be able to receive a TLP of this maximum size, and should not generate TLP's larger than this value. Software must set this field based on the maximum payload size in the Device Capabilities Register, and the capability of the other side."]
    #[inline(always)]
    #[must_use]
    pub fn mp(&mut self) -> MpW<PciExpressDeviceControlAndStatusSpec> {
        MpW::new(self, 5)
    }
    #[doc = "Bit 11 - Enable no snoop \\[ENS\\]
If this bit is Set, the Function is permitted to Set the No Snoop bit in the Requester Attributes of transactions it initiates that do not require hardware enforced cache coherency."]
    #[inline(always)]
    #[must_use]
    pub fn ens(&mut self) -> EnsW<PciExpressDeviceControlAndStatusSpec> {
        EnsW::new(self, 11)
    }
    #[doc = "Bits 12:14 - Max Read Request Size \\[MRR\\]
Specifies the maximum size allowed in read requests generated by the device."]
    #[inline(always)]
    #[must_use]
    pub fn mrr(&mut self) -> MrrW<PciExpressDeviceControlAndStatusSpec> {
        MrrW::new(self, 12)
    }
    #[doc = "Bit 16 - Correctable Error Detected \\[CED\\]
Set to 1 by the core when it detects a correctable error, regardless of whether the error is masked."]
    #[inline(always)]
    #[must_use]
    pub fn ced(&mut self) -> CedW<PciExpressDeviceControlAndStatusSpec> {
        CedW::new(self, 16)
    }
    #[doc = "Bit 17 - Non-Fatal Error Detected \\[NFED\\]
Set to 1 by the core when it detects a non-fatal error, regardless of whether the error is masked."]
    #[inline(always)]
    #[must_use]
    pub fn nfed(&mut self) -> NfedW<PciExpressDeviceControlAndStatusSpec> {
        NfedW::new(self, 17)
    }
    #[doc = "Bit 18 - Fatal Error Detected \\[FED\\]
Set to 1 by the core when it detects a fatal error, regardless of whether the error is masked."]
    #[inline(always)]
    #[must_use]
    pub fn fed(&mut self) -> FedW<PciExpressDeviceControlAndStatusSpec> {
        FedW::new(self, 18)
    }
    #[doc = "Bit 19 - Unsupported Request Detected \\[URD\\]
Set to 1 by the core when it receives an unsupported request."]
    #[inline(always)]
    #[must_use]
    pub fn urd(&mut self) -> UrdW<PciExpressDeviceControlAndStatusSpec> {
        UrdW::new(self, 19)
    }
}
#[doc = "PCI Express Device Control and Status Register (no description)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pci_express_device_control_and_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pci_express_device_control_and_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PciExpressDeviceControlAndStatusSpec;
impl crate::RegisterSpec for PciExpressDeviceControlAndStatusSpec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`pci_express_device_control_and_status::R`](R) reader structure"]
impl crate::Readable for PciExpressDeviceControlAndStatusSpec {}
#[doc = "`write(|w| ..)` method takes [`pci_express_device_control_and_status::W`](W) writer structure"]
impl crate::Writable for PciExpressDeviceControlAndStatusSpec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0x000f_0000;
}
#[doc = "`reset()` method sets PCI_EXPRESS_DEVICE_CONTROL_AND_STATUS to value 0x2810"]
impl crate::Resettable for PciExpressDeviceControlAndStatusSpec {
    const RESET_VALUE: u32 = 0x2810;
}
