#[doc = "Register `EMMCCORE_SADDR` reader"]
pub type R = crate::R<EmmccoreSaddrSpec>;
#[doc = "Register `EMMCCORE_SADDR` writer"]
pub type W = crate::W<EmmccoreSaddrSpec>;
#[doc = "Field `SADDR` reader - This register contains the physical system memory address used\n\nfor DMA transfers or the second argument for the Auto CMD23.\n\n(1) SDMA System Address\n\nThis register contains the system memory address for a SDMA\n\ntransfer. When the Host Controller stops a SDMA transfer, this\n\nregister shall point to the system address of the next contiguous\n\ndata position. It can be accessed only if no transaction is\n\nexecuting (i.e., after a transaction has stopped). Read operations\n\nduring transfers may return an invalid value. The Host Driver\n\nshall initialize this register before starting a SDMA transaction.\n\nAfter SDMA has stopped, the next system address of the next\n\ncontiguous data position can be read from this register.\n\nThe SDMA transfer waits at the every boundary specified by the\n\nHost SDMA Buffer Boundary in the Block Size register. The Host\n\nController generates DMA Interrupt to request the Host Driver to\n\nupdate this register. The Host Driver sets the next system\n\naddress of the next data position to this register.\n\nWhen the most upper byte of this register (003h) is written, the\n\nHost Controller restarts the SDMA transfer.\n\nWhen restarting SDMA by the Resume command or by setting\n\nContinue Request in the Block Gap Control register, the Host\n\nController shall start at the next contiguous address stored here\n\nin the SDMA System Address register. ADMA does not use this\n\nregister.\n\n(2) Argument 2\n\nThis register is used with the Auto CMD23 to set a 32-bit block\n\ncount value to the argument of the CMD23 while executing Auto\n\nCMD23.\n\nIf Auto CMD23 is used with ADMA, the full 32-bit block count\n\nvalue can be used. If Auto CMD23 is used without AMDA, the\n\navailable block count value is limited by the Block Count register.\n\n65535 blocks is the maximum value in this case."]
pub type SaddrR = crate::FieldReader<u32>;
#[doc = "Field `SADDR` writer - This register contains the physical system memory address used\n\nfor DMA transfers or the second argument for the Auto CMD23.\n\n(1) SDMA System Address\n\nThis register contains the system memory address for a SDMA\n\ntransfer. When the Host Controller stops a SDMA transfer, this\n\nregister shall point to the system address of the next contiguous\n\ndata position. It can be accessed only if no transaction is\n\nexecuting (i.e., after a transaction has stopped). Read operations\n\nduring transfers may return an invalid value. The Host Driver\n\nshall initialize this register before starting a SDMA transaction.\n\nAfter SDMA has stopped, the next system address of the next\n\ncontiguous data position can be read from this register.\n\nThe SDMA transfer waits at the every boundary specified by the\n\nHost SDMA Buffer Boundary in the Block Size register. The Host\n\nController generates DMA Interrupt to request the Host Driver to\n\nupdate this register. The Host Driver sets the next system\n\naddress of the next data position to this register.\n\nWhen the most upper byte of this register (003h) is written, the\n\nHost Controller restarts the SDMA transfer.\n\nWhen restarting SDMA by the Resume command or by setting\n\nContinue Request in the Block Gap Control register, the Host\n\nController shall start at the next contiguous address stored here\n\nin the SDMA System Address register. ADMA does not use this\n\nregister.\n\n(2) Argument 2\n\nThis register is used with the Auto CMD23 to set a 32-bit block\n\ncount value to the argument of the CMD23 while executing Auto\n\nCMD23.\n\nIf Auto CMD23 is used with ADMA, the full 32-bit block count\n\nvalue can be used. If Auto CMD23 is used without AMDA, the\n\navailable block count value is limited by the Block Count register.\n\n65535 blocks is the maximum value in this case."]
pub type SaddrW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
impl R {
    #[doc = "Bits 0:31 - This register contains the physical system memory address used\n\nfor DMA transfers or the second argument for the Auto CMD23.\n\n(1) SDMA System Address\n\nThis register contains the system memory address for a SDMA\n\ntransfer. When the Host Controller stops a SDMA transfer, this\n\nregister shall point to the system address of the next contiguous\n\ndata position. It can be accessed only if no transaction is\n\nexecuting (i.e., after a transaction has stopped). Read operations\n\nduring transfers may return an invalid value. The Host Driver\n\nshall initialize this register before starting a SDMA transaction.\n\nAfter SDMA has stopped, the next system address of the next\n\ncontiguous data position can be read from this register.\n\nThe SDMA transfer waits at the every boundary specified by the\n\nHost SDMA Buffer Boundary in the Block Size register. The Host\n\nController generates DMA Interrupt to request the Host Driver to\n\nupdate this register. The Host Driver sets the next system\n\naddress of the next data position to this register.\n\nWhen the most upper byte of this register (003h) is written, the\n\nHost Controller restarts the SDMA transfer.\n\nWhen restarting SDMA by the Resume command or by setting\n\nContinue Request in the Block Gap Control register, the Host\n\nController shall start at the next contiguous address stored here\n\nin the SDMA System Address register. ADMA does not use this\n\nregister.\n\n(2) Argument 2\n\nThis register is used with the Auto CMD23 to set a 32-bit block\n\ncount value to the argument of the CMD23 while executing Auto\n\nCMD23.\n\nIf Auto CMD23 is used with ADMA, the full 32-bit block count\n\nvalue can be used. If Auto CMD23 is used without AMDA, the\n\navailable block count value is limited by the Block Count register.\n\n65535 blocks is the maximum value in this case."]
    #[inline(always)]
    pub fn saddr(&self) -> SaddrR {
        SaddrR::new(self.bits)
    }
}
impl W {
    #[doc = "Bits 0:31 - This register contains the physical system memory address used\n\nfor DMA transfers or the second argument for the Auto CMD23.\n\n(1) SDMA System Address\n\nThis register contains the system memory address for a SDMA\n\ntransfer. When the Host Controller stops a SDMA transfer, this\n\nregister shall point to the system address of the next contiguous\n\ndata position. It can be accessed only if no transaction is\n\nexecuting (i.e., after a transaction has stopped). Read operations\n\nduring transfers may return an invalid value. The Host Driver\n\nshall initialize this register before starting a SDMA transaction.\n\nAfter SDMA has stopped, the next system address of the next\n\ncontiguous data position can be read from this register.\n\nThe SDMA transfer waits at the every boundary specified by the\n\nHost SDMA Buffer Boundary in the Block Size register. The Host\n\nController generates DMA Interrupt to request the Host Driver to\n\nupdate this register. The Host Driver sets the next system\n\naddress of the next data position to this register.\n\nWhen the most upper byte of this register (003h) is written, the\n\nHost Controller restarts the SDMA transfer.\n\nWhen restarting SDMA by the Resume command or by setting\n\nContinue Request in the Block Gap Control register, the Host\n\nController shall start at the next contiguous address stored here\n\nin the SDMA System Address register. ADMA does not use this\n\nregister.\n\n(2) Argument 2\n\nThis register is used with the Auto CMD23 to set a 32-bit block\n\ncount value to the argument of the CMD23 while executing Auto\n\nCMD23.\n\nIf Auto CMD23 is used with ADMA, the full 32-bit block count\n\nvalue can be used. If Auto CMD23 is used without AMDA, the\n\navailable block count value is limited by the Block Count register.\n\n65535 blocks is the maximum value in this case."]
    #[inline(always)]
    #[must_use]
    pub fn saddr(&mut self) -> SaddrW<EmmccoreSaddrSpec> {
        SaddrW::new(self, 0)
    }
}
#[doc = "System address/ Argument 2 register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`emmccore_saddr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`emmccore_saddr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EmmccoreSaddrSpec;
impl crate::RegisterSpec for EmmccoreSaddrSpec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`emmccore_saddr::R`](R) reader structure"]
impl crate::Readable for EmmccoreSaddrSpec {}
#[doc = "`write(|w| ..)` method takes [`emmccore_saddr::W`](W) writer structure"]
impl crate::Writable for EmmccoreSaddrSpec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets EMMCCORE_SADDR to value 0"]
impl crate::Resettable for EmmccoreSaddrSpec {
    const RESET_VALUE: u32 = 0;
}
